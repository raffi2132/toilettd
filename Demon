--[[
    Fish Detection and Selection System v2.0 - QUEUE SYSTEM
    Tujuan: Mendeteksi daftar ikan di inventory
    Fitur:
    - GUI untuk melihat nama ikan + mutasi, dengan navigasi berurutan
    - Auto Trade dengan retry mechanism (max 3x) + Continue Trade
    - Auto Enchant
    - Auto Select SECRET Tier Only
    - NEW: Queue System dengan Chat Coordination
    - NEW: Auto-send "DONE" signal
    - NEW: Chat listener untuk queue coordination
--]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")

local LocalPlayer = Players.LocalPlayer

-- State variables
local currentTab = "Fish" -- "Fish", "Players", or "AutoTrade"
local selectedTradePartner = nil
local autoTradeStatus = "Idle" -- "Idle", "Trading", "Success", "Failed", "Error"
local isAutoTrading = false
local isPaused = false -- Paused state when retry fails
local tradeQueue = {}
local currentTradeIndex = 1
local tradedFishCount = 0
local tradedFishTotalValue = 0 -- Total value of successfully traded fish
local targetTradeValue = 0 -- Target value for auto-selecting fish
local currentRetryCount = 0 -- Current retry attempt for failed trade
local MAX_RETRY_ATTEMPTS = 3 -- Maximum retry attempts

-- Variables for fish detection
local detectedFish = {}
local currentIndex = 1
local isDetecting = false
local fishDetectionWindow = nil
local selectedFishIndices = {} -- Track which fish are selected
local searchTerm = "" -- Current search term
local displayedFish = {} -- Currently displayed fish (filtered or all)
local currentCategory = "Fishes" -- "Fishes" or "Items"

-- Auto Enchant Variables
local isAutoEnchantOn = false
local targetEnchantID = 12 -- Default: Cursed I
local enchantFound = false
local enchantAttempts = 0
local enchantConnection = nil
local ENCHANT_HOTBAR_SLOT = 2 -- Fixed hotbar slot for enchant stone (force equip to slot 2)

-- Auto Accept Trade Variables
local isAutoAcceptTradeOn = false
local autoAcceptConnection = nil
local acceptedTradesCount = 0

-- ====== QUEUE SYSTEM VARIABLES ======
local isQueueModeEnabled = false
local selectedWaitForPlayer = nil -- Player object yang ditunggu signal "DONE" nya (nil = first in queue)
local queueTimeout = 300 -- Timeout dalam detik (default 5 menit)
local waitingForPlayer = nil -- Player name yang sedang ditunggu untuk kirim "DONE"
local timeoutStartTime = 0 -- Waktu mulai timeout
local queueStatus = "Idle" -- "Idle", "Waiting", "Trading", "Done", "Timeout"
local chatMessageConnection = nil -- Connection untuk MessageReceived
local timeoutCheckConnection = nil -- Connection untuk check timeout
local queueSignalKeyword = "DONE" -- Keyword untuk signal queue

-- Enchant Database
local enchantDatabase = {
    ["Cursed I"] = 12,
    ["Leprechaun I"] = 5,
    ["Leprechaun II"] = 6
}

-- Modules for equipping fish
local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
local VendorUtility = require(ReplicatedStorage.Shared.VendorUtility)
local TierUtility = require(ReplicatedStorage.Shared.TierUtility)
local Replion = require(ReplicatedStorage.Packages.Replion)
local PlayerData = Replion.Client:WaitReplion("Data")
local EquipItemEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RE/EquipItem")
local ActivateEnchantEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RE/ActivateEnchantingAltar")
local RollEnchantRemote = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RE/RollEnchant")
local EquipToolFromHotbarEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RE/EquipToolFromHotbar")
local AwaitTradeResponseRemote = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RF/AwaitTradeResponse")

-- Helper function to trim whitespace from a string
local function trim(s)
    if not s then return nil end
    return s:match("^%s*(.-)%s*$")
end

-- Helper function to format price with commas
local function formatPrice(price)
    if not price or price == 0 then return "0" end
    local formatted = tostring(math.floor(price))
    -- Add commas every 3 digits
    formatted = formatted:reverse():gsub("(%d%d%d)", "%1,")
    formatted = formatted:reverse():gsub("^,", "")
    return formatted
end

-- Function to calculate statistics for selected fish
local function calculateSelectedFishStats()
    local totalCount = 0
    local totalValue = 0

    for index, _ in pairs(selectedFishIndices) do
        if detectedFish[index] then
            totalCount = totalCount + 1
            totalValue = totalValue + (detectedFish[index].price or 0)
        end
    end

    return totalCount, totalValue
end

-- Forward declaration for the main UI update function
local updateDisplay
local startAutoTrade
local stopAutoTrade
local pauseTrade
local continueTrade
local processNextTrade

-- Forward declaration for Queue System functions
local setupQueueChatListener
local sendDoneSignal
local checkQueueTimeout
local startQueueTimeout
local stopQueueTimeout
local getExpectedPreviousPlayer
local isMyTurnToTrade
local startQueuedAutoTrade

-- ====== AUTO ENCHANT FUNCTIONS ======
-- Enchanting Altar CFrame
local ENCHANT_ALTAR_CFRAME = CFrame.new(3235.87402, -1302.85486, 1397.36438, 0.540208638, -1.06509411e-07, -0.841531157, -4.86407581e-10, 1, -1.26878462e-07, 0.841531157, 6.89501647e-08, 0.540208638)

-- Function to teleport to enchanting altar
local function teleportToEnchantAltar()
    local character = LocalPlayer.Character
    if not character then
        warn("[Auto Enchant] Character not found for teleport")
        return false
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        warn("[Auto Enchant] HumanoidRootPart not found for teleport")
        return false
    end

    print("[Auto Enchant] ðŸš€ Teleporting to enchanting altar...")
    pcall(function()
        rootPart.CFrame = ENCHANT_ALTAR_CFRAME
    end)
    task.wait(1) -- Wait for teleport to complete
    print("[Auto Enchant] âœ… Teleport complete!")
    return true
end

-- Function to find enchant stone UUID in inventory
local function findEnchantStoneUUID()
    if not PlayerData then return nil end

    local success, inventoryItems = pcall(function()
        return PlayerData:GetExpect("Inventory").Items
    end)

    if not success or not inventoryItems then return nil end

    for _, item in ipairs(inventoryItems) do
        local itemSuccess, itemData = pcall(function()
            return ItemUtility:GetItemData(item.Id)
        end)

        if itemSuccess and itemData and itemData.Data and itemData.Data.Name then
            local itemName = trim(itemData.Data.Name)
            if itemName == "Enchant Stone" or string.find(itemName:lower(), "enchant") then
                return item.UUID
            end
        end
    end

    return nil
end


-- Function to force equip enchant stone to slot 2
local function autoEquipEnchantStone()
    local uuid = findEnchantStoneUUID()
    if not uuid then
        warn("[Auto Enchant] âŒ No enchant stone found!")
        return false
    end

    -- Equip to hotbar
    pcall(function()
        EquipItemEvent:FireServer(uuid, "Enchant Stones")
    end)

    task.wait(2)

    -- Equip from hotbar slot 2 to character
    pcall(function()
        EquipToolFromHotbarEvent:FireServer(ENCHANT_HOTBAR_SLOT)
    end)

    print("[Auto Enchant] âœ… Enchant stone equipped!")
    task.wait(1)

    return true
end

-- Function to activate enchanting altar
local function activateEnchantingAltar()
    pcall(function()
        ActivateEnchantEvent:FireServer()
    end)
    task.wait(1.5)
end

-- Function to handle enchant roll result
local function onEnchantRoll(...)
    local args = {...}
    local enchantId = args[2]

    enchantAttempts = enchantAttempts + 1
    print(string.format("[Auto Enchant] ðŸŽ² Attempt #%d: Got ID %d (Target: %d)", enchantAttempts, enchantId, targetEnchantID))

    if enchantId == targetEnchantID then
        print(string.format("[Auto Enchant] ðŸŽ‰ SUCCESS! Found target ID %d after %d attempts!", targetEnchantID, enchantAttempts))
        enchantFound = true
    end
end

-- Main auto enchant loop
local function startAutoEnchant()
    if not isAutoEnchantOn then return end

    print(string.format("[Auto Enchant] ðŸš€ Starting auto enchant for target ID: %d", targetEnchantID))
    enchantFound = false
    enchantAttempts = 0

    -- Connect to enchant result event
    if RollEnchantRemote and not enchantConnection then
        enchantConnection = RollEnchantRemote.OnClientEvent:Connect(onEnchantRoll)
    end

    -- UI Auto-refresh loop
    task.spawn(function()
        while isAutoEnchantOn and not enchantFound do
            task.wait(3)
            if fishDetectionWindow and currentTab == "Enchant" then
                updateDisplay()
            end
        end
        if fishDetectionWindow and currentTab == "Enchant" then
            updateDisplay()
        end
    end)

    -- Main enchant loop
    task.spawn(function()
        print("[Auto Enchant] ðŸ“ Teleporting to altar...")
        teleportToEnchantAltar()
        task.wait(1)

        while isAutoEnchantOn and not enchantFound do
            -- Equip enchant stone
            autoEquipEnchantStone()

            -- Activate altar
            activateEnchantingAltar()

            -- Wait for result
            task.wait(2)

            if not enchantFound and isAutoEnchantOn then
                task.wait(0.5)
            end
        end

        -- Cleanup
        if enchantConnection then
            enchantConnection:Disconnect()
            enchantConnection = nil
        end

        if enchantFound then
            print(string.format("[Auto Enchant] âœ… COMPLETED! Found ID %d after %d attempts!", targetEnchantID, enchantAttempts))
        else
            print("[Auto Enchant] â›” Stopped!")
        end
    end)
end

-- Function to stop auto enchant
local function stopAutoEnchant()
    isAutoEnchantOn = false
    enchantFound = true

    if enchantConnection then
        enchantConnection:Disconnect()
        enchantConnection = nil
    end

    print("[Auto Enchant] ðŸ›‘ Auto enchant stopped!")
end

-- ====== QUEUE SYSTEM FUNCTIONS ======

-- Function to check if it's my turn to trade
isMyTurnToTrade = function()
    if not isQueueModeEnabled then
        return true -- Queue mode OFF, langsung bisa trade
    end

    if not selectedWaitForPlayer then
        return true -- No player selected to wait for, first in queue
    end

    -- Player selected to wait for, harus tunggu signal
    return false
end

-- Function to send DONE signal via chat (ALWAYS sends after trade complete)
sendDoneSignal = function()
    print("[Auto Trade] ðŸ“¤ Sending DONE signal to chat...")

    local success, err = pcall(function()
        local textChannels = TextChatService:FindFirstChild("TextChannels")
        if not textChannels then
            warn("[Auto Trade] âŒ TextChannels not found!")
            return
        end

        local generalChannel = textChannels:FindFirstChild("RBXGeneral")
        if not generalChannel then
            warn("[Auto Trade] âŒ RBXGeneral channel not found!")
            return
        end

        -- Send the DONE message
        generalChannel:SendAsync(queueSignalKeyword)
        print(string.format("[Auto Trade] âœ… Successfully sent '%s' signal in chat!", queueSignalKeyword))

        -- Update queue status if queue mode enabled
        if isQueueModeEnabled then
            queueStatus = "Done"
        end

        if fishDetectionWindow then
            updateDisplay()
        end
    end)

    if not success then
        warn("[Auto Trade] âŒ Failed to send DONE signal:", tostring(err))
    end
end

-- Function to handle timeout check
checkQueueTimeout = function()
    if not isQueueModeEnabled or queueStatus ~= "Waiting" then
        return
    end

    local elapsedTime = os.time() - timeoutStartTime

    if elapsedTime >= queueTimeout then
        print(string.format("[Queue] â±ï¸ Timeout reached! (%d seconds)", queueTimeout))
        print("[Queue] ðŸš€ Auto-starting trade due to timeout...")

        queueStatus = "Timeout"
        stopQueueTimeout()

        -- Start auto trade
        if fishDetectionWindow then
            updateDisplay()
        end

        task.wait(1)
        startAutoTrade()
    end
end

-- Function to start timeout timer
startQueueTimeout = function()
    if timeoutCheckConnection then
        return -- Already running
    end

    timeoutStartTime = os.time()
    print(string.format("[Queue] â±ï¸ Starting timeout timer (%d seconds)...", queueTimeout))

    -- Create a loop to check timeout every second
    timeoutCheckConnection = task.spawn(function()
        while isQueueModeEnabled and queueStatus == "Waiting" do
            task.wait(1)
            checkQueueTimeout()
        end
    end)
end

-- Function to stop timeout timer
stopQueueTimeout = function()
    if timeoutCheckConnection then
        task.cancel(timeoutCheckConnection)
        timeoutCheckConnection = nil
        print("[Queue] â±ï¸ Timeout timer stopped.")
    end
end

-- Function to setup chat listener for DONE messages
setupQueueChatListener = function()
    if not isQueueModeEnabled then
        return
    end

    if chatMessageConnection then
        chatMessageConnection:Disconnect()
        chatMessageConnection = nil
    end

    if not selectedWaitForPlayer then
        print("[Queue] â„¹ï¸ No player selected to wait for (First in queue).")
        return
    end

    local expectedPlayerName = selectedWaitForPlayer.Name

    print(string.format("[Queue] ðŸ‘‚ Listening for '%s' from player: %s", queueSignalKeyword, expectedPlayerName))

    queueStatus = "Waiting"
    waitingForPlayer = expectedPlayerName

    -- Start timeout timer
    startQueueTimeout()

    -- Setup message listener
    chatMessageConnection = TextChatService.MessageReceived:Connect(function(message)
        print(string.format("[Queue Debug] ðŸ“¨ Message received: '%s'", message.Text or "nil"))

        if not isQueueModeEnabled or queueStatus ~= "Waiting" then
            print(string.format("[Queue Debug] â¸ï¸ Skipped - isQueueModeEnabled: %s, queueStatus: %s", tostring(isQueueModeEnabled), queueStatus))
            return
        end

        local textSource = message.TextSource
        if not textSource then
            print("[Queue Debug] âš ï¸ No TextSource in message")
            return
        end

        -- Get sender player
        local senderId = textSource.UserId
        local senderPlayer = Players:GetPlayerByUserId(senderId)

        if not senderPlayer then
            print("[Queue Debug] âš ï¸ Could not get sender player from UserId:", senderId)
            return
        end

        print(string.format("[Queue Debug] ðŸ‘¤ Sender: %s (expected: %s)", senderPlayer.Name, expectedPlayerName))

        -- Check if sender is the expected player
        if senderPlayer.Name == expectedPlayerName then
            -- Check if message contains the keyword
            local messageText = message.Text
            if messageText and messageText:upper():find(queueSignalKeyword:upper()) then
                print(string.format("[Queue] âœ… Received '%s' from %s!", queueSignalKeyword, senderPlayer.Name))

                -- Stop timeout
                stopQueueTimeout()

                -- Update status
                queueStatus = "Trading"
                waitingForPlayer = nil

                -- Update UI
                if fishDetectionWindow then
                    updateDisplay()
                end

                -- Small delay then start auto trade
                task.wait(2)
                print("[Queue] ðŸš€ Force starting auto trade...")
                startAutoTrade()

                -- Disconnect listener after receiving signal
                if chatMessageConnection then
                    chatMessageConnection:Disconnect()
                    chatMessageConnection = nil
                end
            else
                print(string.format("[Queue Debug] âŒ Message doesn't contain '%s': '%s'", queueSignalKeyword, messageText or "nil"))
            end
        else
            print(string.format("[Queue Debug] âŒ Sender '%s' is not expected player '%s'", senderPlayer.Name, expectedPlayerName))
        end
    end)

    print("[Queue] âœ… Chat listener setup complete!")
end

-- Function to start auto trade with queue coordination
startQueuedAutoTrade = function()
    if not isQueueModeEnabled then
        -- Queue mode OFF, langsung start auto trade biasa
        startAutoTrade()
        return
    end

    -- Check if it's our turn
    if isMyTurnToTrade() then
        print("[Queue] ðŸŽ¯ First in queue (no wait): Starting trade immediately...")
        queueStatus = "Trading"
        startAutoTrade()
    else
        print(string.format("[Queue] â³ Waiting for %s to send 'DONE'...", selectedWaitForPlayer.Name))
        setupQueueChatListener()

        if fishDetectionWindow then
            updateDisplay()
        end
    end
end

-- Auto Accept Trade Functions
local originalTradeCallback = nil
local hasInstalledHook = false
local metaHook = nil

local function startAutoAcceptTrade()
    if isAutoAcceptTradeOn then
        print("[Auto Accept] Already running!")
        return
    end

    print("[Auto Accept] ðŸŸ¢ Starting Auto Accept Trade...")
    isAutoAcceptTradeOn = true
    acceptedTradesCount = 0

    -- Install hook if not already installed
    if not hasInstalledHook then
        task.spawn(function()
            -- Wait for controller to finish setup
            print("[Auto Accept] â³ Waiting 3s for controller setup...")
            task.wait(3)

            print("[Auto Accept] ðŸ“¡ Installing callback hook using hookmetamethod...")

            -- Get the current callback using getcallbackvalue
            local currentCallback = getcallbackvalue(AwaitTradeResponseRemote, "OnClientInvoke")
            originalTradeCallback = currentCallback
            print("[Auto Accept] ðŸ’¾ Got original callback via getcallbackvalue")

            -- Create our wrapper callback
            -- IMPORTANT: Parameters are NOT (category, itemData, sender)!
            -- Based on incoming signal.lua, it's (nil, itemData, sender, timestamp)
            local function autoAcceptCallback(...)
                local args = {...}
                -- Based on incoming signal.lua: (nil, itemData, sender, timestamp)
                local arg1, itemData, sender, timestamp = args[1], args[2], args[3], args[4]

                -- Safe logging with nil checks
                local senderName = sender and sender.Name or "Unknown"
                local itemId = itemData and itemData.Id or "Unknown"

                print(string.format("[Auto Accept] ðŸ”” CALLBACK TRIGGERED! From: %s, Item: %s", senderName, tostring(itemId)))
                print(string.format("[Auto Accept] ðŸ”” Args: arg1=%s, itemData=%s, sender=%s, timestamp=%s",
                    tostring(arg1), tostring(itemData), tostring(sender), tostring(timestamp)))

                if not isAutoAcceptTradeOn then
                    -- If auto-accept is off, use original callback
                    print("[Auto Accept] â¸ï¸ Auto-accept OFF, using original callback")
                    if originalTradeCallback then
                        return originalTradeCallback(...)
                    end
                    return false
                end

                print(string.format("[Auto Accept] ðŸ“¦ Trade request from: %s", senderName))
                print(string.format("[Auto Accept] ðŸ“¦ Item ID: %s", tostring(itemId)))

                acceptedTradesCount = acceptedTradesCount + 1
                print(string.format("[Auto Accept] âœ… Auto-accepting trade #%d from %s", acceptedTradesCount, senderName))

                -- Update UI
                if fishDetectionWindow and currentTab == "AutoTrade" then
                    task.spawn(function()
                        task.wait(0.1)
                        updateDisplay()
                    end)
                end

                -- Auto-accept by directly firing BindableEvent
                task.spawn(function()
                        local PlayerGui = LocalPlayer.PlayerGui

                        -- Wait for prompt GUI to appear
                        local Prompt = PlayerGui:WaitForChild("Prompt", 5)
                        if not Prompt then
                            warn("[Auto Accept] âš ï¸ Prompt GUI timeout!")
                            return
                        end

                        local YesButton = Prompt:WaitForChild("Blackout", 2)
                        if YesButton then
                            YesButton = YesButton:WaitForChild("Options", 2)
                            if YesButton then
                                YesButton = YesButton:WaitForChild("Yes", 2)
                            end
                        end

                        if not YesButton then
                            warn("[Auto Accept] âš ï¸ Yes button not found!")
                            return
                        end

                        print("[Auto Accept] ðŸ“ Yes button found")

                        -- Find the BindableEvent that PromptController uses
                        local bindableEvent = nil

                        -- Method 1: Search for BindableEvent in upvalues of button connections
                        for _, connection in pairs(getconnections(YesButton.MouseButton1Click)) do
                            local func = connection.Function
                            if func then
                                -- Try to find BindableEvent in function upvalues
                                local i = 1
                                while true do
                                    local name, value = debug.getupvalue(func, i)
                                    if not name then break end

                                    if typeof(value) == "Instance" and value:IsA("BindableEvent") then
                                        bindableEvent = value
                                        print("[Auto Accept] ðŸ” Found BindableEvent via upvalue!")
                                        break
                                    end
                                    i = i + 1
                                end
                            end
                            if bindableEvent then break end
                        end

                        -- Method 2: Search in ReplicatedStorage or workspace for BindableEvent
                        if not bindableEvent then
                            print("[Auto Accept] ðŸ” Searching for BindableEvent in game...")

                            -- Try to find it in descendants
                            for _, obj in ipairs(game:GetDescendants()) do
                                if obj:IsA("BindableEvent") and obj.Name == "BindableEvent" then
                                    -- Test if this is the right one by checking nearby references
                                    bindableEvent = obj
                                    print("[Auto Accept] ðŸ” Found potential BindableEvent: " .. obj:GetFullName())
                                    break
                                end
                            end
                        end

                        -- Method 3: Use firesignal on the button directly
                        if not bindableEvent then
                            print("[Auto Accept] âš ï¸ BindableEvent not found, using firesignal method...")
                        end

                        -- Wait for initial cooldown
                        local initialInactive = YesButton:GetAttribute("Inactive")
                        if initialInactive then
                            local currentTime = workspace:GetServerTimeNow()
                            local waitTime = math.max(initialInactive - currentTime, 0)
                            print(string.format("[Auto Accept] â³ Initial cooldown: %.2fs", waitTime))
                            task.wait(waitTime + 0.1)
                        end

                        -- Simulate first click (sets 3-second cooldown)
                        print("[Auto Accept] ðŸ–±ï¸ First click...")
                        for _, connection in pairs(getconnections(YesButton.MouseButton1Click)) do
                            connection:Fire()
                        end

                        -- Wait for 3-second cooldown
                        task.wait(0.2)
                        local secondInactive = YesButton:GetAttribute("Inactive")
                        if secondInactive then
                            local currentTime = workspace:GetServerTimeNow()
                            local waitTime = math.max(secondInactive - currentTime, 0)
                            print(string.format("[Auto Accept] â³ Second cooldown: %.2fs", waitTime))
                            task.wait(waitTime + 0.1)
                        else
                            print("[Auto Accept] â³ Fallback: 3s")
                            task.wait(3)
                        end

                        -- Final accept
                        print("[Auto Accept] âœ… Accepting trade...")
                        if bindableEvent then
                            -- Directly fire the BindableEvent with true
                            pcall(function()
                                bindableEvent:Fire(true)
                            end)
                            print("[Auto Accept] âœ… Fired BindableEvent directly!")
                        else
                            -- Fallback: Try multiple methods
                            print("[Auto Accept] ðŸ”§ Trying fallback methods...")

                            -- Method 1: Fire connections
                            local fired = false
                            for _, connection in pairs(getconnections(YesButton.MouseButton1Click)) do
                                pcall(function()
                                    connection:Fire()
                                    fired = true
                                end)
                            end

                            if fired then
                                print("[Auto Accept] âœ… Fired via connections!")
                            end

                            -- Method 2: Try firesignal if available
                            if firesignal then
                                pcall(function()
                                    firesignal(YesButton.MouseButton1Click)
                                end)
                                print("[Auto Accept] âœ… Tried firesignal!")
                            end

                            -- Method 3: Try clicking via GuiService
                            pcall(function()
                                local VirtualInputManager = game:GetService("VirtualInputManager")
                                local absolutePosition = YesButton.AbsolutePosition
                                local absoluteSize = YesButton.AbsoluteSize
                                local centerX = absolutePosition.X + absoluteSize.X / 2
                                local centerY = absolutePosition.Y + absoluteSize.Y / 2

                                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
                                task.wait(0.05)
                                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
                            end)
                            print("[Auto Accept] âœ… Tried VirtualInput!")
                        end

                        print("[Auto Accept] âœ… Trade accept sequence completed!")
                    end)

                    -- IMPORTANT: We must call the original callback to display the prompt
                    -- The task.spawn above will auto-click it
                    if originalTradeCallback then
                        print("[Auto Accept] ðŸ“ž Calling original callback (prompt will appear, we'll auto-click)...")
                        local result = originalTradeCallback(...)
                        print(string.format("[Auto Accept] ðŸ“ž Original callback returned: %s", tostring(result)))
                        return result
                    else
                        warn("[Auto Accept] âš ï¸ No original callback! Returning false.")
                        return false
                    end
                end

            -- Set our wrapper callback
            AwaitTradeResponseRemote.OnClientInvoke = autoAcceptCallback
            print("[Auto Accept] âœ… Set wrapper callback")

            -- Hook __newindex to track if controller overwrites our callback
            metaHook = hookmetamethod(game, "__newindex", function(self, key, value)
                if rawequal(self, AwaitTradeResponseRemote) and
                   rawequal(key, "OnClientInvoke") and
                   typeof(value) == "function" and
                   not checkcaller() then
                    -- Controller is trying to set callback, save it and replace with ours
                    print("[Auto Accept] ðŸ”„ Controller set new callback, saving and replacing...")
                    originalTradeCallback = value
                    return metaHook(self, key, autoAcceptCallback)
                end
                return metaHook(self, key, value)
            end)

            hasInstalledHook = true
            print("[Auto Accept] âœ… Hook installed successfully with metamethod protection!")
        end)
    end
end

local function stopAutoAcceptTrade()
    if not isAutoAcceptTradeOn then
        print("[Auto Accept] Already stopped!")
        return
    end

    print("[Auto Accept] ðŸ›‘ Stopping Auto Accept Trade...")
    isAutoAcceptTradeOn = false

    -- Restore original callback if we have it stored
    if originalTradeCallback and AwaitTradeResponseRemote then
        AwaitTradeResponseRemote.OnClientInvoke = originalTradeCallback
        print("[Auto Accept] ðŸ”„ Original callback restored")
    end

    print(string.format("[Auto Accept] ðŸ“Š Total trades auto-accepted: %d", acceptedTradesCount))
    print("[Auto Accept] ðŸ›‘ Auto-accept trade stopped!")
end

-- Helper function to find and equip a fish (uses UUID directly)
local function equipFishByData(fishToEquip)
    if not fishToEquip or not PlayerData then
        warn("[equipFishByData] Missing fishToEquip or PlayerData")
        return {success = false, uuid = nil}
    end

    local uuid = fishToEquip.uuid
    if not uuid then
        warn(string.format("[equipFishByData] No UUID found for fish: %s", tostring(fishToEquip.name)))
        return {success = false, uuid = nil}
    end

    local result = {success = false, uuid = nil}

    local ok, err = pcall(function()
        -- Check if already equipped
        local equippedItems = PlayerData:GetExpect("EquippedItems")
        for _, equippedUUID in ipairs(equippedItems) do
            if equippedUUID == uuid then
                print(string.format("[equipFishByData] Item '%s' (UUID: %s) is already equipped",
                    fishToEquip.name, uuid))
                result.success = true
                result.uuid = uuid
                return
            end
        end

        -- Determine the correct category based on itemType
        local category = "Fish"
        if fishToEquip.itemType == "Fish" then
            category = "Fish"
        elseif fishToEquip.category == "Items" then
            category = "Items"
        end

        print(string.format("[equipFishByData] Equipping '%s' (mutation: %s, UUID: %s, category: %s)",
            fishToEquip.name, tostring(fishToEquip.mutation), uuid, category))

        EquipItemEvent:FireServer(uuid, category)
        result.success = true
        result.uuid = uuid
    end)

    if not ok then
        warn(string.format("[equipFishByData] Pcall failed for '%s': %s",
            tostring(fishToEquip.name), tostring(err)))
    end

    return result
end

-- Trading Function
local function selectTradePartner(player)
    if not player.Character then
        print("[Trade] Player character not loaded for: " .. player.Name)
    end

    selectedTradePartner = {
        Name = player.Name,
        UserId = player.UserId,
        CharacterAppearanceId = player.CharacterAppearanceId
    }
    print(string.format("[Trade] Selected partner: %s (UserId: %d, AppearanceId: %s)",
        selectedTradePartner.Name, selectedTradePartner.UserId, tostring(selectedTradePartner.CharacterAppearanceId)))

    updateDisplay()
end

-- Auto Trade Functions with Retry Mechanism
startAutoTrade = function()
    if isAutoTrading then return end

    local selectedCount = 0
    for _ in pairs(selectedFishIndices) do selectedCount = selectedCount + 1 end

    if not selectedTradePartner then
        autoTradeStatus = "Error: No player selected."
        updateDisplay()
        return
    end
    if selectedCount == 0 then
        autoTradeStatus = "Error: No fish selected."
        updateDisplay()
        return
    end

    tradeQueue = {}
    for originalIndex, _ in pairs(selectedFishIndices) do
        if detectedFish[originalIndex] then
            table.insert(tradeQueue, detectedFish[originalIndex])
        end
    end

    if #tradeQueue == 0 then
        autoTradeStatus = "Error: Could not create trade queue from selected fish."
        updateDisplay()
        return
    end

    isAutoTrading = true
    isPaused = false
    currentTradeIndex = 1
    tradedFishCount = 0
    tradedFishTotalValue = 0
    currentRetryCount = 0
    autoTradeStatus = "Starting auto trade..."
    updateDisplay()

    task.spawn(processNextTrade)
end

stopAutoTrade = function(reason)
    if not isAutoTrading then return end
    isAutoTrading = false
    isPaused = false
    tradeQueue = {}
    currentTradeIndex = 1
    currentRetryCount = 0
    autoTradeStatus = reason or "Stopped by user."
    updateDisplay()
end

pauseTrade = function(reason)
    isPaused = true
    autoTradeStatus = reason or "â¸ï¸ Trade paused. Click 'Continue Trade' to resume."
    updateDisplay()
end

continueTrade = function()
    if not isAutoTrading or not isPaused then return end

    isPaused = false
    currentRetryCount = 0 -- Reset retry count untuk fresh start
    autoTradeStatus = string.format("â–¶ï¸ Resuming trade from fish %d/%d...", currentTradeIndex, #tradeQueue)
    updateDisplay()

    task.spawn(processNextTrade)
end

processNextTrade = function()
    if not isAutoTrading then return end
    if isPaused then return end -- Stop jika paused

    if currentTradeIndex > #tradeQueue then
        autoTradeStatus = string.format("âœ… All fish traded successfully! Total: %d/%d | Value: %s C$", tradedFishCount, #tradeQueue, formatPrice(tradedFishTotalValue))
        isAutoTrading = false
        selectedFishIndices = {}

        -- AUTO CHAT "DONE" - ALWAYS send after all trades complete
        print("[Auto Trade] ðŸ“¤ All trades completed! Sending DONE signal in 2 seconds...")
        updateDisplay()
        task.wait(2) -- 2 second cooldown
        sendDoneSignal()

        updateDisplay()
        return
    end

    local fishToTrade = tradeQueue[currentTradeIndex]
    local retryText = currentRetryCount > 0 and string.format(" (Retry %d/%d)", currentRetryCount, MAX_RETRY_ATTEMPTS) or ""
    autoTradeStatus = string.format("Trading %d/%d: Equipping '%s'...%s", currentTradeIndex, #tradeQueue, fishToTrade.name, retryText)
    updateDisplay()

    task.wait(1.5)

    local equipResult = equipFishByData(fishToTrade)
    if not equipResult.success then
        if currentRetryCount < MAX_RETRY_ATTEMPTS then
            currentRetryCount = currentRetryCount + 1
            autoTradeStatus = string.format("âš ï¸ Failed to equip '%s'. Retrying... (%d/%d)", fishToTrade.name, currentRetryCount, MAX_RETRY_ATTEMPTS)
            updateDisplay()
            task.wait(2)
            processNextTrade() -- Retry same fish
            return
        else
            -- Max retries reached, pause trading
            pauseTrade(string.format("âŒ Failed to equip '%s' after %d attempts. Click 'Continue Trade' to retry.", fishToTrade.name, MAX_RETRY_ATTEMPTS))
            return
        end
    end

    autoTradeStatus = string.format("Trading %d/%d: Waiting for equip confirmation...%s", currentTradeIndex, #tradeQueue, retryText)
    updateDisplay()

    local equipConfirmed = false
    local startTime = tick()
    repeat
        task.wait(0.1)
        local equippedItems = PlayerData:GetExpect("EquippedItems")
        for _, equippedUUID in ipairs(equippedItems) do
            if equippedUUID == equipResult.uuid then
                equipConfirmed = true
                break
            end
        end
        if equipConfirmed then break end
    until tick() - startTime > 5

    if not equipConfirmed then
        if currentRetryCount < MAX_RETRY_ATTEMPTS then
            currentRetryCount = currentRetryCount + 1
            autoTradeStatus = string.format("âš ï¸ Equip not confirmed for '%s'. Retrying... (%d/%d)", fishToTrade.name, currentRetryCount, MAX_RETRY_ATTEMPTS)
            updateDisplay()
            task.wait(2)
            processNextTrade() -- Retry same fish
            return
        else
            -- Max retries reached, pause trading
            pauseTrade(string.format("âŒ Equip confirmation failed for '%s' after %d attempts. Click 'Continue Trade' to retry.", fishToTrade.name, MAX_RETRY_ATTEMPTS))
            return
        end
    end

    autoTradeStatus = string.format("Trading %d/%d: Item confirmed. Initiating trade...%s", currentTradeIndex, #tradeQueue, retryText)
    updateDisplay()
    task.wait(1.5)

    local success, result = pcall(function()
        local InitiateTradeFunc = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/InitiateTrade"]
        return InitiateTradeFunc:InvokeServer(selectedTradePartner.UserId, tostring(equipResult.uuid))
    end)

    if success and result then
        autoTradeStatus = string.format("Trading %d/%d: Request sent. Waiting for response...", currentTradeIndex, #tradeQueue)
        currentRetryCount = 0 -- Reset retry count on successful trade request
    else
        local failReason = (not success) and tostring(result) or "Player busy/declined/far"

        if currentRetryCount < MAX_RETRY_ATTEMPTS then
            currentRetryCount = currentRetryCount + 1
            autoTradeStatus = string.format("âš ï¸ Trade failed: %s. Retrying... (%d/%d)", failReason, currentRetryCount, MAX_RETRY_ATTEMPTS)
            updateDisplay()
            task.wait(3)
            processNextTrade() -- Retry same fish
            return
        else
            -- Max retries reached, pause trading
            pauseTrade(string.format("âŒ Trade failed for '%s' after %d attempts: %s. Click 'Continue Trade' to retry.", fishToTrade.name, MAX_RETRY_ATTEMPTS, failReason))
            return
        end
    end
    updateDisplay()
end


-- Create the GUI Library (simplified version)
local FishDetectorLib = {}

do
    local function getResponsiveSize()
        local viewport = workspace.CurrentCamera.ViewportSize
        local isMobile = viewport.X < 800 or viewport.Y < 600

        if isMobile then
            return {
                windowWidth = math.min(viewport.X * 0.9, 350),
                windowHeight = math.min(viewport.Y * 0.8, 450),
                titleSize = 16,
                textSize = 13,
                buttonHeight = 35,
                padding = 8
            }
        else
            return {
                windowWidth = 400,
                windowHeight = 500,
                titleSize = 18,
                textSize = 14,
                buttonHeight = 38,
                padding = 12
            }
        end
    end

    local function createWindow(titleText)
        local existingGui = CoreGui:FindFirstChild("FishDetector_UI")
        if existingGui then
            existingGui:Destroy()
        end

        local responsive = getResponsiveSize()

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "FishDetector_UI"
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true
        screenGui.DisplayOrder = 1000
        screenGui.Parent = CoreGui

        local mainFrame = Instance.new("Frame")
        mainFrame.Name = "MainFrame"
        mainFrame.Size = UDim2.new(0, responsive.windowWidth, 0, responsive.windowHeight)
        mainFrame.Position = UDim2.new(0.5, -responsive.windowWidth/2, 0.5, -responsive.windowHeight/2)
        mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
        mainFrame.Parent = screenGui
        mainFrame.Active = true
        mainFrame.ClipsDescendants = true

        local mainCorner = Instance.new("UICorner")
        mainCorner.CornerRadius = UDim.new(0, 14)
        mainCorner.Parent = mainFrame

        local mainStroke = Instance.new("UIStroke")
        mainStroke.Color = Color3.fromRGB(70, 130, 200)
        mainStroke.Thickness = 2.5
        mainStroke.Transparency = 0.3
        mainStroke.Parent = mainFrame

        local mainShadow = Instance.new("ImageLabel")
        mainShadow.Name = "Shadow"
        mainShadow.Size = UDim2.new(1, 20, 1, 20)
        mainShadow.Position = UDim2.new(0, -10, 0, -10)
        mainShadow.BackgroundTransparency = 1
        mainShadow.Image = "rbxasset://textures/ui/GuiImagePlaceholder.png"
        mainShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        mainShadow.ImageTransparency = 0.7
        mainShadow.ZIndex = -1
        mainShadow.Parent = mainFrame

        local topBar = Instance.new("Frame")
        topBar.Name = "TopBar"
        topBar.Size = UDim2.new(1, 0, 0, 45)
        topBar.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
        topBar.Parent = mainFrame

        local topCorner = Instance.new("UICorner")
        topCorner.CornerRadius = UDim.new(0, 14)
        topCorner.Parent = topBar

        local topGradient = Instance.new("UIGradient")
        topGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 50, 65)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 30, 40))
        })
        topGradient.Rotation = 90
        topGradient.Parent = topBar

        local titleLabel = Instance.new("TextLabel")
        titleLabel.Name = "Title"
        titleLabel.BackgroundTransparency = 1
        titleLabel.Size = UDim2.new(1, -100, 1, 0)
        titleLabel.Position = UDim2.new(0, 15, 0, 0)
        titleLabel.Font = Enum.Font.GothamBold
        titleLabel.Text = titleText or "ðŸŸ Fish Detector"
        titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        titleLabel.TextSize = responsive.titleSize
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.TextYAlignment = Enum.TextYAlignment.Center
        titleLabel.Parent = topBar

        local minimizeButton = Instance.new("TextButton")
        minimizeButton.Name = "MinimizeButton"
        minimizeButton.Size = UDim2.new(0, 30, 0, 30)
        minimizeButton.Position = UDim2.new(1, -70, 0.5, -15)
        minimizeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        minimizeButton.Text = "â”€"
        minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        minimizeButton.TextSize = 18
        minimizeButton.Font = Enum.Font.GothamBold
        minimizeButton.Parent = topBar

        local minimizeCorner = Instance.new("UICorner")
        minimizeCorner.CornerRadius = UDim.new(0, 6)
        minimizeCorner.Parent = minimizeButton

        local closeButton = Instance.new("TextButton")
        closeButton.Name = "CloseButton"
        closeButton.Size = UDim2.new(0, 30, 0, 30)
        closeButton.Position = UDim2.new(1, -35, 0.5, -15)
        closeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        closeButton.Text = "Ã—"
        closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        closeButton.TextSize = 18
        closeButton.Font = Enum.Font.GothamBold
        closeButton.Parent = topBar

        local closeCorner = Instance.new("UICorner")
        closeCorner.CornerRadius = UDim.new(0, 6)
        closeCorner.Parent = closeButton

        local contentFrame = Instance.new("ScrollingFrame")
        contentFrame.Name = "Content"
        contentFrame.BackgroundTransparency = 1
        contentFrame.Size = UDim2.new(1, -20, 1, -60)
        contentFrame.Position = UDim2.new(0, 10, 0, 50)
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        contentFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        contentFrame.ScrollBarThickness = 6
        contentFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 80)
        contentFrame.Parent = mainFrame

        local contentLayout = Instance.new("UIListLayout")
        contentLayout.FillDirection = Enum.FillDirection.Vertical
        contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        contentLayout.Padding = UDim.new(0, responsive.padding)
        contentLayout.Parent = contentFrame

        local contentPadding = Instance.new("UIPadding")
        contentPadding.PaddingLeft = UDim.new(0, responsive.padding)
        contentPadding.PaddingRight = UDim.new(0, responsive.padding)
        contentPadding.PaddingTop = UDim.new(0, responsive.padding)
        contentPadding.PaddingBottom = UDim.new(0, responsive.padding * 2)
        contentPadding.Parent = contentFrame

        local dragging = false
        local dragStart, startPos
        topBar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = mainFrame.Position
                local changeConn
                changeConn = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                        if changeConn then changeConn:Disconnect() end
                    end
                end)
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - dragStart
                local viewport = workspace.CurrentCamera.ViewportSize
                local newPosX = math.clamp(startPos.X.Offset + delta.X, 0, viewport.X - responsive.windowWidth)
                local newPosY = math.clamp(startPos.Y.Offset + delta.Y, 0, viewport.Y - responsive.windowHeight)
                mainFrame.Position = UDim2.new(0, newPosX, 0, newPosY)
            end
        end)

        local isMinimized = false
        local originalHeight = responsive.windowHeight

        local window = {
            _screenGui = screenGui,
            _mainFrame = mainFrame,
            _contentFrame = contentFrame,
            _closeButton = closeButton,
            _minimizeButton = minimizeButton,
            _topBar = topBar,
            _isMinimized = false,
        }

        function window:Minimize()
            isMinimized = not isMinimized
            self._isMinimized = isMinimized

            if isMinimized then
                self._contentFrame.Visible = false
                self._mainFrame:TweenSize(
                    UDim2.new(0, responsive.windowWidth, 0, 45),
                    Enum.EasingDirection.Out,
                    Enum.EasingStyle.Quad,
                    0.3,
                    true
                )
                self._minimizeButton.Text = "â–¡"
            else
                self._mainFrame:TweenSize(
                    UDim2.new(0, responsive.windowWidth, 0, originalHeight),
                    Enum.EasingDirection.Out,
                    Enum.EasingStyle.Quad,
                    0.3,
                    true
                )
                task.wait(0.3)
                self._contentFrame.Visible = true
                self._minimizeButton.Text = "â”€"
            end
        end

        function window:AddButton(text, callback)
            local button = Instance.new("TextButton")
            button.Name = "Button"
            button.BackgroundColor3 = Color3.fromRGB(60, 140, 255)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.Font = Enum.Font.GothamSemibold
            button.Text = text
            button.TextSize = responsive.textSize
            button.AutoButtonColor = false
            button.Size = UDim2.new(1, 0, 0, responsive.buttonHeight)
            button.Parent = self._contentFrame

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = button

            local gradient = Instance.new("UIGradient")
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(70, 150, 255)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 120, 235))
            })
            gradient.Rotation = 90
            gradient.Parent = button

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(80, 160, 255)
            stroke.Thickness = 1.5
            stroke.Transparency = 0.5
            stroke.Parent = button

            button.MouseEnter:Connect(function()
                button:TweenSize(UDim2.new(1, 0, 0, responsive.buttonHeight + 2), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.1, true)
                stroke.Transparency = 0.2
            end)
            button.MouseLeave:Connect(function()
                button:TweenSize(UDim2.new(1, 0, 0, responsive.buttonHeight), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.1, true)
                stroke.Transparency = 0.5
            end)
            button.MouseButton1Click:Connect(function() if callback then pcall(callback) end end)
            return button
        end

        function window:AddLabel(text)
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.BackgroundColor3 = Color3.fromRGB(30, 35, 45)
            label.TextColor3 = Color3.fromRGB(220, 220, 230)
            label.Font = Enum.Font.Gotham
            label.Text = text
            label.TextSize = responsive.textSize
            label.AutomaticSize = Enum.AutomaticSize.Y
            label.Size = UDim2.new(1, 0, 0, 0)
            label.TextWrapped = true
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.TextYAlignment = Enum.TextYAlignment.Top
            label.Parent = self._contentFrame

            local labelPadding = Instance.new("UIPadding")
            labelPadding.PaddingLeft = UDim.new(0, responsive.padding)
            labelPadding.PaddingRight = UDim.new(0, responsive.padding)
            labelPadding.PaddingTop = UDim.new(0, responsive.padding / 2)
            labelPadding.PaddingBottom = UDim.new(0, responsive.padding / 2)
            labelPadding.Parent = label

            local labelCorner = Instance.new("UICorner")
            labelCorner.CornerRadius = UDim.new(0, 8)
            labelCorner.Parent = label

            local labelStroke = Instance.new("UIStroke")
            labelStroke.Color = Color3.fromRGB(60, 70, 90)
            labelStroke.Thickness = 1.5
            labelStroke.Transparency = 0.5
            labelStroke.Parent = label

            return label
        end

        function window:AddSimpleSearchBar(placeholder, onSearch)
            local searchFrame = Instance.new("Frame")
            searchFrame.Name = "SimpleSearchFrame"
            searchFrame.BackgroundColor3 = Color3.fromRGB(35, 40, 50)
            searchFrame.Size = UDim2.new(1, 0, 0, responsive.buttonHeight)
            searchFrame.Parent = self._contentFrame

            local searchCorner = Instance.new("UICorner")
            searchCorner.CornerRadius = UDim.new(0, 8)
            searchCorner.Parent = searchFrame

            local searchStroke = Instance.new("UIStroke")
            searchStroke.Color = Color3.fromRGB(100, 120, 150)
            searchStroke.Thickness = 2
            searchStroke.Transparency = 0.3
            searchStroke.Parent = searchFrame

            local searchBox = Instance.new("TextBox")
            searchBox.Name = "SimpleSearchBox"
            searchBox.BackgroundTransparency = 1
            searchBox.Size = UDim2.new(1, -20, 1, 0)
            searchBox.Position = UDim2.new(0, 10, 0, 0)
            searchBox.Font = Enum.Font.Gotham
            searchBox.PlaceholderText = placeholder or "Search fish..."
            searchBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
            searchBox.Text = ""
            searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
            searchBox.TextSize = responsive.textSize
            searchBox.TextXAlignment = Enum.TextXAlignment.Left
            searchBox.TextYAlignment = Enum.TextYAlignment.Center
            searchBox.ClearTextOnFocus = false
            searchBox.Parent = searchFrame

            searchBox.Focused:Connect(function()
                searchStroke.Color = Color3.fromRGB(70, 150, 255)
                searchStroke.Thickness = 2.5
                searchStroke.Transparency = 0
            end)
            searchBox.FocusLost:Connect(function()
                searchStroke.Color = Color3.fromRGB(100, 120, 150)
                searchStroke.Thickness = 2
                searchStroke.Transparency = 0.3
            end)

            local debounceTime = 0.3
            local lastChangeTime = 0
            searchBox:GetPropertyChangedSignal("Text"):Connect(function()
                lastChangeTime = tick()
                local currentChangeTime = lastChangeTime
                task.wait(debounceTime)
                if currentChangeTime == lastChangeTime and onSearch then onSearch(searchBox.Text) end
            end)
            return searchBox
        end

        function window:AddNumberInput(placeholder, defaultValue, onValueChange)
            local inputFrame = Instance.new("Frame")
            inputFrame.Name = "NumberInputFrame"
            inputFrame.BackgroundColor3 = Color3.fromRGB(35, 45, 60)
            inputFrame.Size = UDim2.new(1, 0, 0, responsive.buttonHeight)
            inputFrame.Parent = self._contentFrame

            local inputCorner = Instance.new("UICorner")
            inputCorner.CornerRadius = UDim.new(0, 8)
            inputCorner.Parent = inputFrame

            local inputStroke = Instance.new("UIStroke")
            inputStroke.Color = Color3.fromRGB(100, 180, 255)
            inputStroke.Thickness = 2.5
            inputStroke.Transparency = 0.3
            inputStroke.Parent = inputFrame

            local numberBox = Instance.new("TextBox")
            numberBox.Name = "NumberBox"
            numberBox.BackgroundTransparency = 1
            numberBox.Size = UDim2.new(1, -20, 1, 0)
            numberBox.Position = UDim2.new(0, 10, 0, 0)
            numberBox.Font = Enum.Font.GothamBold
            numberBox.PlaceholderText = placeholder or "Enter value..."
            numberBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
            numberBox.Text = defaultValue and formatPrice(defaultValue) or ""
            numberBox.TextColor3 = Color3.fromRGB(255, 196, 57)
            numberBox.TextSize = responsive.textSize
            numberBox.TextXAlignment = Enum.TextXAlignment.Left
            numberBox.TextYAlignment = Enum.TextYAlignment.Center
            numberBox.ClearTextOnFocus = false
            numberBox.Parent = inputFrame

            numberBox.Focused:Connect(function()
                inputStroke.Color = Color3.fromRGB(80, 220, 120)
                inputStroke.Thickness = 3
                inputStroke.Transparency = 0
            end)

            numberBox.FocusLost:Connect(function()
                inputStroke.Color = Color3.fromRGB(100, 180, 255)
                inputStroke.Thickness = 2.5
                inputStroke.Transparency = 0.3

                local text = numberBox.Text:gsub(",", ""):gsub("%.", "")
                local number = tonumber(text)

                if number and number > 0 then
                    numberBox.Text = formatPrice(number)
                    if onValueChange then
                        onValueChange(number)
                    end
                else
                    numberBox.Text = ""
                end
            end)

            return numberBox, inputFrame
        end

        function window:AddFishEntry(fishName, mutation, isCurrent, isSelected, fishIndex, price, tierName)
            local specialFish = {
                ["Megalodon"] = true, ["Blob Shark"] = true, ["Plasma Shark"] = true,
                ["Frostborn Shark"] = true, ["Giant Squid"] = true, ["Ghost Shark"] = true,
                ["Robot Kraken"] = true
            }

            local entry = Instance.new("TextButton")
            entry.Name = "FishEntry"
            entry.AutoButtonColor = false
            entry.Text = ""

            local hasMutation = mutation and mutation ~= ""
            local isSpecial = specialFish[fishName]
            local isSecret = tierName == "SECRET"

            if isSelected then
                entry.BackgroundColor3 = Color3.fromRGB(50, 130, 245)
            elseif isCurrent then
                entry.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            elseif isSecret then
                entry.BackgroundColor3 = Color3.fromRGB(10, 80, 60)
            elseif isSpecial then
                entry.BackgroundColor3 = Color3.fromRGB(60, 20, 80)
            elseif hasMutation then
                entry.BackgroundColor3 = Color3.fromRGB(80, 60, 20)
            else
                entry.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            end

            entry.Size = UDim2.new(1, 0, 0, 75)
            entry.Parent = self._contentFrame

            local entryCorner = Instance.new("UICorner")
            entryCorner.CornerRadius = UDim.new(0, 8)
            entryCorner.Parent = entry

            local entryStroke = Instance.new("UIStroke")
            if isSelected then
                entryStroke.Color = Color3.fromRGB(70, 150, 255)
                entryStroke.Thickness = 2
            elseif isCurrent then
                entryStroke.Color = Color3.fromRGB(100, 100, 100)
                entryStroke.Thickness = 2
            elseif isSecret then
                entryStroke.Color = Color3.fromRGB(23, 255, 151)
                entryStroke.Thickness = 2
            elseif isSpecial then
                entryStroke.Color = Color3.fromRGB(170, 80, 255)
                entryStroke.Thickness = 1.5
            elseif hasMutation then
                entryStroke.Color = Color3.fromRGB(255, 190, 0)
                entryStroke.Thickness = 1.5
            else
                entryStroke.Color = Color3.fromRGB(55, 55, 55)
                entryStroke.Thickness = 1
            end
            entryStroke.Parent = entry

            local entryPadding = Instance.new("UIPadding")
            entryPadding.PaddingLeft = UDim.new(0, responsive.padding)
            entryPadding.PaddingRight = UDim.new(0, responsive.padding)
            entryPadding.PaddingTop = UDim.new(0, responsive.padding / 2)
            entryPadding.PaddingBottom = UDim.new(0, responsive.padding / 2)
            entryPadding.Parent = entry

            local selectionIndicator = Instance.new("Frame")
            selectionIndicator.Name = "SelectionIndicator"
            selectionIndicator.Size = UDim2.new(0, 4, 1, -10)
            selectionIndicator.Position = UDim2.new(1, -10, 0, 5)
            selectionIndicator.BackgroundColor3 = isSelected and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            selectionIndicator.BorderSizePixel = 0
            selectionIndicator.Visible = isSelected
            selectionIndicator.Parent = entry

            local indicatorCorner = Instance.new("UICorner")
            indicatorCorner.CornerRadius = UDim.new(0, 2)
            indicatorCorner.Parent = selectionIndicator

            local fishNameLabel = Instance.new("TextLabel")
            fishNameLabel.Name = "FishName"
            fishNameLabel.BackgroundTransparency = 1
            fishNameLabel.Size = UDim2.new(1, -20, 0, 20)
            fishNameLabel.Position = UDim2.new(0, 0, 0, 0)
            fishNameLabel.Font = Enum.Font.GothamSemibold
            local prefix = isSecret and "ðŸŒŸ " or (isSelected and "âœ… " or "ðŸŸ ")
            fishNameLabel.Text = prefix .. tostring(fishName)
            fishNameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            fishNameLabel.TextSize = responsive.textSize
            fishNameLabel.TextXAlignment = Enum.TextXAlignment.Left
            fishNameLabel.TextYAlignment = Enum.TextYAlignment.Center
            fishNameLabel.Parent = entry

            local mutationLabel = Instance.new("TextLabel")
            mutationLabel.Name = "Mutation"
            mutationLabel.BackgroundTransparency = 1
            mutationLabel.Size = UDim2.new(1, -20, 0, 18)
            mutationLabel.Position = UDim2.new(0, 0, 0, 22)
            mutationLabel.Font = Enum.Font.Gotham
            mutationLabel.Text = mutation and ("âœ¨ " .. tostring(mutation)) or "âšª No Mutation"
            mutationLabel.TextColor3 = hasMutation and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(150, 150, 150)
            mutationLabel.TextSize = responsive.textSize - 1
            mutationLabel.TextXAlignment = Enum.TextXAlignment.Left
            mutationLabel.TextYAlignment = Enum.TextYAlignment.Center
            mutationLabel.Parent = entry

            local priceLabel = Instance.new("TextLabel")
            priceLabel.Name = "PriceLabel"
            priceLabel.BackgroundTransparency = 1
            priceLabel.Size = UDim2.new(1, -20, 0, 18)
            priceLabel.Position = UDim2.new(0, 0, 0, 42)
            priceLabel.Font = Enum.Font.GothamBold
            local tierText = tierName and (" | " .. tierName) or ""
            priceLabel.Text = price and (("ðŸ’° " .. formatPrice(price) .. " C$") .. tierText) or "ðŸ’° N/A"
            priceLabel.TextColor3 = isSecret and Color3.fromRGB(23, 255, 151) or Color3.fromRGB(255, 196, 57)
            priceLabel.TextSize = responsive.textSize - 1
            priceLabel.TextXAlignment = Enum.TextXAlignment.Left
            priceLabel.TextYAlignment = Enum.TextYAlignment.Center
            priceLabel.Parent = entry

            entry.MouseButton1Click:Connect(function()
                local wasSelected = selectedFishIndices[fishIndex]
                if wasSelected then selectedFishIndices[fishIndex] = nil
                else selectedFishIndices[fishIndex] = true end
                updateDisplay()
            end)

            entry.MouseEnter:Connect(function()
                if not isSelected then
                    if isCurrent then
                        entry.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
                    elseif isSecret then
                        entry.BackgroundColor3 = Color3.fromRGB(20, 100, 80)
                    elseif isSpecial then
                        entry.BackgroundColor3 = Color3.fromRGB(80, 40, 100)
                    elseif hasMutation then
                        entry.BackgroundColor3 = Color3.fromRGB(100, 80, 40)
                    else
                        entry.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
                    end
                end
            end)

            entry.MouseLeave:Connect(function()
                if isSelected then
                    entry.BackgroundColor3 = Color3.fromRGB(50, 130, 245)
                elseif isCurrent then
                    entry.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                elseif isSecret then
                    entry.BackgroundColor3 = Color3.fromRGB(10, 80, 60)
                elseif isSpecial then
                    entry.BackgroundColor3 = Color3.fromRGB(60, 20, 80)
                elseif hasMutation then
                    entry.BackgroundColor3 = Color3.fromRGB(80, 60, 20)
                else
                    entry.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
                end
            end)
            return entry
        end

        function window:AddGroupEntry(groupName, itemCount, isExpanded, onToggle, onSelectAll, totalValue, avgPrice)
            local entry = Instance.new("TextButton")
            entry.Name = "GroupEntry"
            entry.AutoButtonColor = false
            entry.Text = ""
            entry.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            entry.Size = UDim2.new(1, 0, 0, 65)
            entry.Parent = self._contentFrame

            local entryCorner = Instance.new("UICorner")
            entryCorner.CornerRadius = UDim.new(0, 8)
            entryCorner.Parent = entry

            local entryStroke = Instance.new("UIStroke")
            entryStroke.Color = Color3.fromRGB(70, 130, 200)
            entryStroke.Thickness = 2
            entryStroke.Parent = entry

            local entryPadding = Instance.new("UIPadding")
            entryPadding.PaddingLeft = UDim.new(0, responsive.padding)
            entryPadding.PaddingRight = UDim.new(0, responsive.padding)
            entryPadding.PaddingTop = UDim.new(0, responsive.padding / 2)
            entryPadding.PaddingBottom = UDim.new(0, responsive.padding / 2)
            entryPadding.Parent = entry

            local expandIcon = Instance.new("TextLabel")
            expandIcon.Name = "ExpandIcon"
            expandIcon.BackgroundTransparency = 1
            expandIcon.Size = UDim2.new(0, 20, 0, 20)
            expandIcon.Position = UDim2.new(0, 0, 0, 5)
            expandIcon.Font = Enum.Font.GothamBold
            expandIcon.Text = isExpanded and "â–¼" or "â–¶"
            expandIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
            expandIcon.TextSize = responsive.textSize
            expandIcon.Parent = entry

            local groupNameLabel = Instance.new("TextLabel")
            groupNameLabel.Name = "GroupName"
            groupNameLabel.BackgroundTransparency = 1
            groupNameLabel.Size = UDim2.new(1, -70, 0, 20)
            groupNameLabel.Position = UDim2.new(0, 25, 0, 5)
            groupNameLabel.Font = Enum.Font.GothamBold
            groupNameLabel.Text = "ðŸ“¦ " .. groupName
            groupNameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            groupNameLabel.TextSize = responsive.textSize
            groupNameLabel.TextXAlignment = Enum.TextXAlignment.Left
            groupNameLabel.Parent = entry

            local countLabel = Instance.new("TextLabel")
            countLabel.Name = "Count"
            countLabel.BackgroundTransparency = 1
            countLabel.Size = UDim2.new(1, -25, 0, 18)
            countLabel.Position = UDim2.new(0, 25, 0, 25)
            countLabel.Font = Enum.Font.Gotham
            countLabel.Text = string.format("ðŸ”¢ Count: %d", itemCount)
            countLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
            countLabel.TextSize = responsive.textSize - 1
            countLabel.TextXAlignment = Enum.TextXAlignment.Left
            countLabel.Parent = entry

            local priceLabel = Instance.new("TextLabel")
            priceLabel.Name = "PriceInfo"
            priceLabel.BackgroundTransparency = 1
            priceLabel.Size = UDim2.new(1, -25, 0, 18)
            priceLabel.Position = UDim2.new(0, 25, 0, 42)
            priceLabel.Font = Enum.Font.GothamBold
            priceLabel.Text = string.format("ðŸ’° Total: %s C$ | Avg: %s C$",
                formatPrice(totalValue or 0), formatPrice(avgPrice or 0))
            priceLabel.TextColor3 = Color3.fromRGB(255, 196, 57)
            priceLabel.TextSize = responsive.textSize - 1
            priceLabel.TextXAlignment = Enum.TextXAlignment.Left
            priceLabel.Parent = entry

            local selectAllButton = Instance.new("TextButton")
            selectAllButton.Name = "SelectAllButton"
            selectAllButton.Size = UDim2.new(0, 50, 0, 30)
            selectAllButton.Position = UDim2.new(1, -55, 0.5, -15)
            selectAllButton.BackgroundColor3 = Color3.fromRGB(50, 130, 245)
            selectAllButton.Text = "âœ“ All"
            selectAllButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            selectAllButton.TextSize = responsive.textSize - 2
            selectAllButton.Font = Enum.Font.GothamSemibold
            selectAllButton.Parent = entry

            local selectCorner = Instance.new("UICorner")
            selectCorner.CornerRadius = UDim.new(0, 4)
            selectCorner.Parent = selectAllButton

            entry.MouseButton1Click:Connect(function()
                if onToggle then onToggle() end
            end)

            selectAllButton.MouseButton1Click:Connect(function()
                if onSelectAll then onSelectAll() end
            end)

            entry.MouseEnter:Connect(function()
                entry.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
            end)

            entry.MouseLeave:Connect(function()
                entry.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            end)

            return entry
        end

        function window:ClearContent()
            local contentFrame = self._contentFrame
            for _, child in pairs(contentFrame:GetChildren()) do
                if child:IsA("GuiObject") and not child:IsA("UILayout") and not child:IsA("UIPadding") then
                    child:Destroy()
                end
            end
        end

        function window:Toggle(force)
            if typeof(force) == "boolean" then self._screenGui.Enabled = force
            else self._screenGui.Enabled = not self._screenGui.Enabled end
            return self._screenGui.Enabled
        end

        closeButton.MouseButton1Click:Connect(function() window:Toggle(false) end)
        closeButton.MouseEnter:Connect(function() closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) end)
        closeButton.MouseLeave:Connect(function() closeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40) end)

        minimizeButton.MouseButton1Click:Connect(function() window:Minimize() end)
        minimizeButton.MouseEnter:Connect(function() minimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) end)
        minimizeButton.MouseLeave:Connect(function() minimizeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40) end)

        return window
    end

    function FishDetectorLib.CreateWindow(titleText)
        return createWindow(titleText)
    end
end

-- ============================================================================
-- LIGHTWEIGHT INVENTORY SYSTEM INTEGRATION
-- ============================================================================
local LightweightInventory = {}
do
    local inventoryController, originalDestroyTiles, isInventoryHooked, isLoading = nil, nil, false, false
    local function getInventoryController()
        if inventoryController then return inventoryController end
        local success, result = pcall(function()
            return require(ReplicatedStorage:WaitForChild("Controllers", 5):WaitForChild("InventoryController", 5))
        end)
        if success then inventoryController = result; return inventoryController
        else warn("[Fish Detector] Failed to load Inventory Controller:", result) return nil end
    end
    local function hookInventoryController()
        if isInventoryHooked then return true end
        local ctrl = getInventoryController()
        if not ctrl then return false end
        originalDestroyTiles = ctrl.DestroyTiles
        ctrl.DestroyTiles = function() return end
        isInventoryHooked = true
        return true
    end
    local function refreshInventoryTiles()
        if isLoading then return end; isLoading = true
        local ctrl = getInventoryController()
        if not ctrl then isLoading = false; return end
        pcall(function() if ctrl.InventoryStateChanged then ctrl.InventoryStateChanged:Fire("Fish") end end)
        task.wait()
        isLoading = false
    end
    local function initialLoadInventoryTiles()
        if isLoading then return end; isLoading = true
        local ctrl = getInventoryController()
        if not ctrl then isLoading = false; return end
        local playerGui = LocalPlayer:WaitForChild("PlayerGui")
        local inventoryGUI = playerGui:FindFirstChild("Inventory")
        local mainFrame = inventoryGUI and inventoryGUI:FindFirstChild("Main")
        if not mainFrame then warn("[Fish Detector] Inventory GUI not found."); isLoading = false; return end
        local previousEnabled, previousVisible = inventoryGUI.Enabled, mainFrame.Visible
        inventoryGUI.Enabled, mainFrame.Visible = true, true
        task.wait(0.2)
        pcall(function()
            if ctrl.SetPage then ctrl.SetPage(ctrl, "Items") end
            if ctrl.SetCategory then ctrl.SetCategory(ctrl, "Fishes") end
            if ctrl.InventoryStateChanged then ctrl.InventoryStateChanged:Fire("Fish") end
        end)
        task.wait(0.5)
        inventoryGUI.Enabled, mainFrame.Visible = previousEnabled, previousVisible
        isLoading = false
    end
    function LightweightInventory.start()
        if isInventoryHooked then return end
        task.spawn(function()
            if hookInventoryController() then
                task.wait(1); initialLoadInventoryTiles()
                pcall(function()
                    local GuiControl = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("GuiControl"))
                    local inventoryGUI = LocalPlayer.PlayerGui:FindFirstChild("Inventory")
                    GuiControl.GuiUnfocusedSignal:Connect(function(closedGui)
                        if closedGui == inventoryGUI then task.delay(0.5, refreshInventoryTiles) end
                    end)
                end)
                pcall(function()
                    local fishCaughtEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RE/FishCaught")
                    fishCaughtEvent.OnClientEvent:Connect(function() task.delay(1, refreshInventoryTiles) end)
                end)
            else warn("[Fish Detector] Could not start inventory system.") end
        end)
    end
    function LightweightInventory.stop()
        if not isInventoryHooked or not inventoryController or not originalDestroyTiles then return end
        inventoryController.DestroyTiles = originalDestroyTiles
        isInventoryHooked, inventoryController, originalDestroyTiles = false, nil, nil
    end
    function LightweightInventory.getController() return getInventoryController() end
end

-- ============================================================================
-- GROUPING SYSTEM - Group items by base name
-- ============================================================================
local isGroupingEnabled = true
local expandedGroups = {}

local function getBaseName(fish)
    if not fish then return "" end
    return fish.name or ""
end

local function groupDetectedFish()
    local groups = {}
    local groupOrder = {}

    for i, fish in ipairs(detectedFish) do
        local baseName = getBaseName(fish)

        if not groups[baseName] then
            groups[baseName] = {
                baseName = baseName,
                items = {},
                totalCount = 0,
                totalValue = 0,
                avgPrice = 0,
                maxPrice = 0,
                minPrice = 999999999,
                isExpanded = expandedGroups[baseName] or false
            }
            table.insert(groupOrder, baseName)
        end

        local fishWithIndex = {}
        for k, v in pairs(fish) do
            fishWithIndex[k] = v
        end
        fishWithIndex.originalIndex = i

        table.insert(groups[baseName].items, fishWithIndex)
        groups[baseName].totalCount = groups[baseName].totalCount + 1

        local itemPrice = fish.price or 0
        groups[baseName].totalValue = groups[baseName].totalValue + itemPrice

        if itemPrice > groups[baseName].maxPrice then
            groups[baseName].maxPrice = itemPrice
        end

        if itemPrice < groups[baseName].minPrice then
            groups[baseName].minPrice = itemPrice
        end
    end

    for _, group in pairs(groups) do
        if group.totalCount > 0 then
            group.avgPrice = math.floor(group.totalValue / group.totalCount)
        end
    end

    return groups, groupOrder
end

local function filterFish(search)
    displayedFish = {}
    searchTerm = (search and string.lower(search) or "")
    if searchTerm == "" then
        for i, fish in ipairs(detectedFish) do table.insert(displayedFish, {fish = fish, originalIndex = i}) end
    else
        for i, fish in ipairs(detectedFish) do
            local fishName = string.lower(fish.name or "")
            local fishMutation = string.lower(fish.mutation or "")
            if string.find(fishName, searchTerm, 1, true) or string.find(fishMutation, searchTerm, 1, true) then
                table.insert(displayedFish, {fish = fish, originalIndex = i})
            end
        end
    end
    if currentIndex > #displayedFish then currentIndex = #displayedFish > 0 and 1 or 1 end
end

local function selectFishByTargetValue(targetValue)
    if targetValue <= 0 or #detectedFish == 0 then
        return 0, 0
    end

    selectedFishIndices = {}

    local nonMutationFish = {}
    local mutationFish = {}

    for i, fish in ipairs(detectedFish) do
        local fishData = {
            index = i,
            price = fish.price or 0,
            fish = fish,
            hasMutation = fish.mutation and fish.mutation ~= ""
        }

        if fishData.hasMutation then
            table.insert(mutationFish, fishData)
        else
            table.insert(nonMutationFish, fishData)
        end
    end

    local currentTotal = 0
    local selectedCount = 0

    if targetValue < 1000000 then
        print("[Auto-Select] Strategy: Under 1M - Prioritizing low-value non-mutation fish")
        table.sort(nonMutationFish, function(a, b) return a.price < b.price end)

        local targetForLow = targetValue * 0.7
        for _, item in ipairs(nonMutationFish) do
            if currentTotal < targetForLow and currentTotal + item.price <= targetValue * 1.1 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

        for _, item in ipairs(nonMutationFish) do
            if not selectedFishIndices[item.index] and currentTotal + item.price <= targetValue * 1.05 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

    elseif targetValue >= 1000000 and targetValue < 2000000 then
        print("[Auto-Select] Strategy: 1M-2M - Mixed selection, non-mutation priority")
        table.sort(nonMutationFish, function(a, b) return a.price < b.price end)

        for _, item in ipairs(nonMutationFish) do
            if currentTotal + item.price <= targetValue * 1.1 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

        table.sort(mutationFish, function(a, b) return a.price < b.price end)
        for _, item in ipairs(mutationFish) do
            if currentTotal + item.price <= targetValue * 1.05 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

    else
        print("[Auto-Select] Strategy: 5M+ - Mixed value selection (medium-low-high)")

        local allFish = {}
        for _, item in ipairs(nonMutationFish) do table.insert(allFish, item) end
        for _, item in ipairs(mutationFish) do table.insert(allFish, item) end

        if #allFish == 0 then
            return 0, 0
        end

        table.sort(allFish, function(a, b) return a.price < b.price end)

        local minPrice = allFish[1].price
        local maxPrice = allFish[#allFish].price
        local priceRange = maxPrice - minPrice

        local lowThreshold = minPrice + (priceRange * 0.33)
        local mediumThreshold = minPrice + (priceRange * 0.66)

        local lowValueFish = {}
        local mediumValueFish = {}
        local highValueFish = {}

        for _, item in ipairs(allFish) do
            if item.price <= lowThreshold then
                table.insert(lowValueFish, item)
            elseif item.price <= mediumThreshold then
                table.insert(mediumValueFish, item)
            else
                table.insert(highValueFish, item)
            end
        end

        local targetMedium = targetValue * 0.4
        local targetLow = targetValue * 0.3

        for _, item in ipairs(mediumValueFish) do
            if currentTotal < targetMedium and currentTotal + item.price <= targetValue * 1.1 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

        for _, item in ipairs(lowValueFish) do
            if currentTotal < targetMedium + targetLow and currentTotal + item.price <= targetValue * 1.1 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

        for _, item in ipairs(highValueFish) do
            if currentTotal + item.price <= targetValue * 1.05 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1
            end
        end

        for _, item in ipairs(allFish) do
            if not selectedFishIndices[item.index] and currentTotal + item.price <= targetValue * 1.05 then
                selectedFishIndices[item.index] = true
                currentTotal = currentTotal + item.price
                selectedCount = selectedCount + 1

                if currentTotal >= targetValue * 0.95 then break end
            end
        end
    end

    local accuracy = (currentTotal / targetValue) * 100
    print(string.format("[Auto-Select] Selected %d fish with total value: %s C$ (Target: %s C$, Accuracy: %.1f%%)",
        selectedCount, formatPrice(currentTotal), formatPrice(targetValue), accuracy))

    return selectedCount, currentTotal
end

-- NEW: Function to select only SECRET tier fish
local function selectSecretFishOnly()
    selectedFishIndices = {}

    local secretCount = 0
    local secretTotalValue = 0

    for i, fish in ipairs(detectedFish) do
        if fish.tierName == "SECRET" then
            selectedFishIndices[i] = true
            secretCount = secretCount + 1
            secretTotalValue = secretTotalValue + (fish.price or 0)
        end
    end

    print(string.format("[Auto-Select SECRET] Selected %d SECRET tier fish with total value: %s C$",
        secretCount, formatPrice(secretTotalValue)))

    return secretCount, secretTotalValue
end

local function getInventoryController() return LightweightInventory.getController() end

local function detectFish()
    detectedFish = {}
    isDetecting = true
    print(string.format("[Fish Detector] Starting %s detection from PlayerData...", currentCategory))

    if not PlayerData then
        warn("[Fish Detector] PlayerData is not available.")
        isDetecting = false
        return false
    end

    local success, inventory = pcall(function()
        return PlayerData:Get("Inventory")
    end)

    if not success or not inventory then
        warn("[Fish Detector] Failed to get inventory from PlayerData:", tostring(inventory))
        isDetecting = false
        return false
    end

    local itemsCategory = inventory["Items"]
    if not itemsCategory or type(itemsCategory) ~= "table" then
        warn("[Fish Detector] 'Items' category not found in inventory data.")
        isDetecting = false
        return false
    end

    print(string.format("[Fish Detector] Found %d total items in 'Items' category.", #itemsCategory))

    local itemCount = 0
    for i, item in ipairs(itemsCategory) do
        local itemData = ItemUtility:GetItemData(item.Id)
        if itemData and itemData.Data then
            local itemType = itemData.Data.Type
            local itemName = trim(itemData.Data.Name)
            local itemUUID = item.UUID

            local shouldInclude = false
            if currentCategory == "Fishes" and itemType == "Fish" then
                shouldInclude = true
            elseif currentCategory == "Items" and itemType ~= "Fish" then
                shouldInclude = true
            end

            if shouldInclude then
                local mutation = nil
                local originalName = itemName

                if string.find(itemName, "^Big ") then
                    mutation = "Big"
                    itemName = trim(string.gsub(itemName, "^Big ", ""))
                elseif string.find(itemName, "^Shiny ") then
                    mutation = "Shiny"
                    itemName = trim(string.gsub(itemName, "^Shiny ", ""))
                end

                if not mutation and item.Metadata and item.Metadata.VariantId then
                    local variantData = ItemUtility:GetVariantData(item.Metadata.VariantId)
                    if variantData and variantData.Data.Name and variantData.Data.Name ~= "Ghoulish" then
                        mutation = variantData.Data.Name
                    end
                end

                local fishPrice = VendorUtility:GetSellPrice(item) or 0
                local basePrice = itemData.SellPrice or 0

                -- Get tier information
                local tierInfo = nil
                local tierName = nil
                if itemData.Probability or itemData.ForcedProbability then
                    local probability = itemData.Probability or itemData.ForcedProbability
                    if itemData.ForcedProbability and itemData.Data.Tier then
                        tierInfo = TierUtility:GetTier(itemData.Data.Tier)
                    else
                        tierInfo = TierUtility:GetTierFromRarity(probability.Chance)
                    end
                    if tierInfo then
                        tierName = tierInfo.Name
                    end
                end

                print(string.format("[detectFish] Found %s: '%s' (original: '%s') with mutation: '%s', UUID: %s, Price: %d C$, Tier: %s",
                    itemType, itemName, originalName, tostring(mutation), itemUUID, fishPrice, tostring(tierName)))

                table.insert(detectedFish, {
                    index = itemCount + 1,
                    name = itemName,
                    originalName = originalName,
                    mutation = mutation,
                    uuid = itemUUID,
                    category = currentCategory,
                    itemType = itemType,
                    price = fishPrice,
                    basePrice = basePrice,
                    tierName = tierName,
                    tierInfo = tierInfo
                })
                itemCount = itemCount + 1
            end
        else
            warn("[Fish Detector] Could not get data for item with ID:", item.Id)
        end
    end

    print(string.format("[Fish Detector] Detection complete. Found %d %s.", itemCount, currentCategory))
    filterFish("")
    isDetecting = false
    return true
end

updateDisplay = function()
    if not fishDetectionWindow then return end

    local contentFrame = fishDetectionWindow._contentFrame
    fishDetectionWindow:ClearContent()

    local tabContainer = Instance.new("Frame")
    tabContainer.Name = "TabContainer"
    tabContainer.Size = UDim2.new(1, 0, 0, 38)
    tabContainer.BackgroundTransparency = 1
    tabContainer.LayoutOrder = -100
    tabContainer.Parent = contentFrame

    local tabLayout = Instance.new("UIListLayout")
    tabLayout.FillDirection = Enum.FillDirection.Horizontal
    tabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    tabLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    tabLayout.Padding = UDim.new(0, 5)
    tabLayout.Parent = tabContainer

    local function createTab(text, tabName)
        local tabButton = Instance.new("TextButton")
        tabButton.Name = tabName .. "Tab"
        tabButton.Size = UDim2.new(0.23, -4, 1, 0)
        tabButton.Font = Enum.Font.GothamSemibold
        tabButton.Text = text
        tabButton.TextSize = 11
        tabButton.AutoButtonColor = false
        tabButton.Parent = tabContainer

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = tabButton

        if currentTab == tabName then
            tabButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        else
            tabButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            tabButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        end

        tabButton.MouseButton1Click:Connect(function()
            if currentTab ~= tabName then
                currentTab = tabName
                updateDisplay()
            end
        end)
        return tabButton
    end

    createTab("ðŸŸ Fish", "Fish")
    createTab("ðŸ‘¥ Players", "Players")
    createTab("ðŸ¤– Auto Trade", "AutoTrade")
    createTab("â±ï¸ Queue", "Queue")
    createTab("âœ¨ Enchant", "Enchant")

    if currentTab == "Fish" then
        local categoryFrame = Instance.new("Frame")
        categoryFrame.Name = "CategoryFrame"
        categoryFrame.Size = UDim2.new(1, 0, 0, 38)
        categoryFrame.BackgroundTransparency = 1
        categoryFrame.LayoutOrder = -99
        categoryFrame.Parent = contentFrame

        local categoryLayout = Instance.new("UIListLayout")
        categoryLayout.FillDirection = Enum.FillDirection.Horizontal
        categoryLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        categoryLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        categoryLayout.Padding = UDim.new(0, 5)
        categoryLayout.Parent = categoryFrame

        local function createCategoryButton(text, category)
            local catButton = Instance.new("TextButton")
            catButton.Name = category .. "Category"
            catButton.Size = UDim2.new(0.5, -3, 1, 0)
            catButton.Font = Enum.Font.GothamSemibold
            catButton.Text = text
            catButton.TextSize = 13
            catButton.AutoButtonColor = false
            catButton.Parent = categoryFrame

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = catButton

            if currentCategory == category then
                catButton.BackgroundColor3 = Color3.fromRGB(50, 130, 245)
                catButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            else
                catButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
                catButton.TextColor3 = Color3.fromRGB(150, 150, 150)
            end

            catButton.MouseButton1Click:Connect(function()
                if currentCategory ~= category then
                    currentCategory = category
                    detectedFish = {}
                    selectedFishIndices = {}
                    currentIndex = 1
                    updateDisplay()
                end
            end)

            catButton.MouseEnter:Connect(function()
                if currentCategory ~= category then
                    catButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
                end
            end)

            catButton.MouseLeave:Connect(function()
                if currentCategory ~= category then
                    catButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
                else
                    catButton.BackgroundColor3 = Color3.fromRGB(50, 130, 245)
                end
            end)

            return catButton
        end

        createCategoryButton("ðŸŸ Fishes", "Fishes")
        createCategoryButton("ðŸ“¦ Items", "Items")

        if #detectedFish == 0 then
            fishDetectionWindow:AddLabel("No " .. string.lower(currentCategory) .. " detected. Try detecting first!")
            fishDetectionWindow:AddButton("ðŸ” Detect " .. currentCategory, function()
                if isDetecting then return end
                detectFish()
                filterFish("")
                updateDisplay()
            end)
            return
        end

        local groupingButtonText = isGroupingEnabled and "ðŸ“‹ List View" or "ðŸ“¦ Group View"
        fishDetectionWindow:AddButton(groupingButtonText, function()
            isGroupingEnabled = not isGroupingEnabled
            updateDisplay()
        end)

        local allItemsTotalValue = 0
        for _, fish in ipairs(detectedFish) do
            allItemsTotalValue = allItemsTotalValue + (fish.price or 0)
        end
        local itemLabel = currentCategory == "Fishes" and "Fish" or "Items"
        fishDetectionWindow:AddLabel(string.format("ðŸ’Ž Total %s Value: %s C$", itemLabel, formatPrice(allItemsTotalValue)))

        local selectedCount = 0
        for _ in pairs(selectedFishIndices) do selectedCount = selectedCount + 1 end

        if selectedCount > 0 then
            local totalCount, totalValue = calculateSelectedFishStats()
            local itemLabel = currentCategory == "Fishes" and "Fish" or "Items"
            fishDetectionWindow:AddLabel(string.format("ðŸ“‹ Selected %s: %d", itemLabel, selectedCount))
            fishDetectionWindow:AddLabel(string.format("ðŸ’° Total Value: %s C$", formatPrice(totalValue)))
        end

        fishDetectionWindow:AddLabel("ðŸŽ¯ Auto-Select by Target Value:")
        fishDetectionWindow:AddNumberInput("Enter target value (e.g., 100000)", targetTradeValue, function(value)
            targetTradeValue = value
            print(string.format("[Target Value] Set to: %s C$", formatPrice(value)))
        end)

        fishDetectionWindow:AddButton("âœ¨ Auto-Select Fish by Value", function()
            if targetTradeValue <= 0 then
                print("[Auto-Select] Please enter a target value first!")
                return
            end
            local count, total = selectFishByTargetValue(targetTradeValue)
            updateDisplay()
        end)

        -- NEW: Auto Select SECRET Button
        fishDetectionWindow:AddButton("ðŸŒŸ Auto-Select SECRET Tier Only", function()
            local count, total = selectSecretFishOnly()
            updateDisplay()
        end)

        local searchPlaceholder = currentCategory == "Fishes" and "Search fish by name or mutation..." or "Search items by name..."
        fishDetectionWindow:AddSimpleSearchBar(searchPlaceholder, function(searchText)
            filterFish(searchText)
            updateDisplay()
        end)

        local totalCount, displayCount = #detectedFish, #displayedFish
        local itemLabel = currentCategory == "Fishes" and "fish" or "items"

        if isGroupingEnabled and searchTerm == "" then
            local groups, groupOrder = groupDetectedFish()
            local totalGroups = #groupOrder

            fishDetectionWindow:AddLabel(string.format("ðŸ“¦ Groups: %d | Total %s: %d", totalGroups, itemLabel, totalCount))

            for _, groupName in ipairs(groupOrder) do
                local group = groups[groupName]

                fishDetectionWindow:AddGroupEntry(
                    groupName,
                    group.totalCount,
                    group.isExpanded,
                    function()
                        expandedGroups[groupName] = not expandedGroups[groupName]
                        updateDisplay()
                    end,
                    function()
                        for _, item in ipairs(group.items) do
                            selectedFishIndices[item.originalIndex] = true
                        end
                        updateDisplay()
                    end,
                    group.totalValue,
                    group.avgPrice
                )

                if group.isExpanded then
                    for _, item in ipairs(group.items) do
                        local isSelected = selectedFishIndices[item.originalIndex] or false
                        fishDetectionWindow:AddFishEntry(item.originalName or item.name, item.mutation, false, isSelected, item.originalIndex, item.price, item.tierName)
                    end
                end
            end

        else
            local navText = searchTerm ~= "" and string.format("Showing %d of %d %s (search: '%s')", displayCount, totalCount, itemLabel, searchTerm) or string.format("%s %d of %d (Use â† â†’ keys to navigate)", itemLabel:sub(1,1):upper()..itemLabel:sub(2), currentIndex, displayCount)
            fishDetectionWindow:AddLabel(navText)

            for i, displayItem in ipairs(displayedFish) do
                local fish, originalIndex = displayItem.fish, displayItem.originalIndex
                local isCurrent, isSelected = (i == currentIndex), selectedFishIndices[originalIndex] or false
                fishDetectionWindow:AddFishEntry(fish.originalName or fish.name, fish.mutation, isCurrent, isSelected, originalIndex, fish.price, fish.tierName)
            end
        end

        fishDetectionWindow:AddButton("ðŸ” Detect " .. currentCategory .. " Again", function()
            if isDetecting then return end
            detectFish()
            currentIndex = 1
            updateDisplay()
        end)

        if not isGroupingEnabled and #displayedFish > 0 then
            local itemName = currentCategory == "Fishes" and "Fish" or "Item"
            fishDetectionWindow:AddButton("â¬…ï¸ Previous " .. itemName, function()
                if currentIndex > 1 then currentIndex = currentIndex - 1; updateDisplay() end
            end)
            fishDetectionWindow:AddButton("âž¡ï¸ Next " .. itemName, function()
                if currentIndex < #displayedFish then currentIndex = currentIndex + 1; updateDisplay() end
            end)
            fishDetectionWindow:AddButton("ðŸŽ¯ Toggle Current " .. itemName, function()
                local displayItem = displayedFish[currentIndex]
                if displayItem then
                    local originalIndex = displayItem.originalIndex
                    if selectedFishIndices[originalIndex] then selectedFishIndices[originalIndex] = nil
                    else selectedFishIndices[originalIndex] = true end
                    updateDisplay()
                end
            end)
        end

        fishDetectionWindow:AddButton("âœ… Select All " .. (currentCategory == "Fishes" and "Fish" or "Items"), function()
            for i = 1, #detectedFish do
                selectedFishIndices[i] = true
            end
            updateDisplay()
        end)

        if selectedCount > 0 then
            fishDetectionWindow:AddButton("ðŸ—‘ï¸ Clear All Selections", function()
                selectedFishIndices = {}; updateDisplay()
            end)
        end

    elseif currentTab == "Players" then
        local order = 1
        local function add(inst) inst.LayoutOrder = order; order = order + 1; return inst end

        add(fishDetectionWindow:AddLabel("Select a player to trade with."))

        if selectedTradePartner then
            add(fishDetectionWindow:AddLabel("ðŸ¤ Trading with: " .. selectedTradePartner.Name))
            add(fishDetectionWindow:AddButton("âŒ Clear Selected Player", function()
                selectedTradePartner = nil
                updateDisplay()
            end))
        end

        local players = Players:GetPlayers()
        if #players <= 1 then
            add(fishDetectionWindow:AddLabel("No other players in the server."))
        else
            for _, player in ipairs(players) do
                if player ~= LocalPlayer then
                    add(fishDetectionWindow:AddButton(player.Name, function()
                        selectTradePartner(player)
                    end))
                end
            end
        end

    elseif currentTab == "AutoTrade" then
        local order = 1
        local function add(inst) inst.LayoutOrder = order; order = order + 1; return inst end

        add(fishDetectionWindow:AddLabel("Auto Trade Automation (Max 3 retries per fish)"))
        add(fishDetectionWindow:AddLabel("ðŸ’¬ Auto-chats 'DONE' after all trades complete"))

        -- Queue Mode Indicator
        if isQueueModeEnabled then
            add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Queue Mode â”â”â”â”â”â”"))
            add(fishDetectionWindow:AddLabel("â±ï¸ Queue Mode: ðŸŸ¢ ENABLED"))
            if selectedWaitForPlayer then
                add(fishDetectionWindow:AddLabel("â³ Waiting for: " .. selectedWaitForPlayer.Name))
            else
                add(fishDetectionWindow:AddLabel("ðŸ“ Position: First in queue"))
            end
            add(fishDetectionWindow:AddLabel("ðŸ’¡ Queue Status: " .. queueStatus))
            add(fishDetectionWindow:AddLabel("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"))
        end

        local selectedCount = 0
        for _ in pairs(selectedFishIndices) do selectedCount = selectedCount + 1 end

        local totalCount, totalValue = calculateSelectedFishStats()

        if selectedTradePartner then
            add(fishDetectionWindow:AddLabel("ðŸŽ¯ Target: " .. selectedTradePartner.Name))
        else
            add(fishDetectionWindow:AddLabel("ðŸŽ¯ Target: None"))
        end

        local itemLabel = currentCategory == "Fishes" and "Fish" or "Items"
        add(fishDetectionWindow:AddLabel(string.format("ðŸ  Selected %s: %d", itemLabel, selectedCount)))
        add(fishDetectionWindow:AddLabel(string.format("ðŸ’° Total Value: %s C$", formatPrice(totalValue))))
        add(fishDetectionWindow:AddLabel(string.format("ðŸ“¦ Traded Fish: %d/%d", tradedFishCount, #tradeQueue)))
        add(fishDetectionWindow:AddLabel(string.format("ðŸ’µ Total Value Traded: %s C$", formatPrice(tradedFishTotalValue))))
        add(fishDetectionWindow:AddLabel("ðŸ’¡ Status: " .. autoTradeStatus))

        -- Show current fish info when paused
        if isPaused and #tradeQueue > 0 and tradeQueue[currentTradeIndex] then
            local currentFish = tradeQueue[currentTradeIndex]
            add(fishDetectionWindow:AddLabel(string.format("â¸ï¸ PAUSED at Fish #%d: %s (%s)", currentTradeIndex, currentFish.name, currentFish.mutation or "No Mutation")))
            add(fishDetectionWindow:AddLabel(string.format("ðŸ’° Fish Value: %s C$ | UUID: %s", formatPrice(currentFish.price or 0), currentFish.uuid)))
        end

        if isAutoTrading and #tradeQueue > 0 then
            local fishList = {}
            local title = "Remaining Trades:"
            for i = currentTradeIndex, #tradeQueue do
                local fish = tradeQueue[i]
                local mutation = fish.mutation or "None"
                table.insert(fishList, string.format(" - %s (%s)", fish.name, mutation))
            end
            if #fishList > 0 then
                add(fishDetectionWindow:AddLabel(title .. "\n" .. table.concat(fishList, "\n")))
            end
        end

        if isAutoTrading then
            if isPaused then
                -- Paused state - show Continue, Skip, and Stop buttons
                add(fishDetectionWindow:AddButton("â–¶ï¸ Continue Trade", function()
                    continueTrade()
                end))
                add(fishDetectionWindow:AddButton("â­ï¸ Skip Current Fish", function()
                    if currentTradeIndex < #tradeQueue then
                        currentTradeIndex = currentTradeIndex + 1
                        autoTradeStatus = string.format("â­ï¸ Skipped fish. Moving to fish %d/%d...", currentTradeIndex, #tradeQueue)
                        continueTrade()
                    else
                        autoTradeStatus = "âœ… No more fish to trade!"
                        isAutoTrading = false
                        isPaused = false
                        updateDisplay()
                    end
                end))
                add(fishDetectionWindow:AddButton("ðŸ›‘ Stop Auto Trade", function()
                    stopAutoTrade("Stopped by user.")
                end))
            else
                -- Running state - show only Stop button
                add(fishDetectionWindow:AddButton("ðŸ›‘ Stop Auto Trade", function()
                    stopAutoTrade("Stopped by user.")
                end))
            end
        else
            add(fishDetectionWindow:AddButton("ðŸš€ Start Auto Trade", startAutoTrade))

            add(fishDetectionWindow:AddButton("ðŸ”„ Reset Status", function()
                if isAutoTrading then return end
                autoTradeStatus = "Idle"
                tradedFishCount = 0
                tradedFishTotalValue = 0
                updateDisplay()
            end))
        end

        -- Auto Accept Trade Section
        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Auto Accept Trade â”â”â”â”â”â”"))
        local acceptStatusText = isAutoAcceptTradeOn and "ðŸŸ¢ ON" or "ðŸ”´ OFF"
        add(fishDetectionWindow:AddLabel("Auto Accept Status: " .. acceptStatusText))
        add(fishDetectionWindow:AddLabel(string.format("âœ… Accepted Trades: %d", acceptedTradesCount)))

        if isAutoAcceptTradeOn then
            add(fishDetectionWindow:AddButton("ðŸ›‘ Stop Auto Accept", function()
                stopAutoAcceptTrade()
                updateDisplay()
            end))
        else
            add(fishDetectionWindow:AddButton("âœ… Start Auto Accept", function()
                startAutoAcceptTrade()
                updateDisplay()
            end))
        end

        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Auto Send Trade â”â”â”â”â”â”"))

    elseif currentTab == "Queue" then
        local order = 1
        local function add(inst) inst.LayoutOrder = order; order = order + 1; return inst end

        add(fishDetectionWindow:AddLabel("â±ï¸ Queue System - Wait for DONE Signal"))
        add(fishDetectionWindow:AddLabel("Select a player to wait for 'DONE' chat signal before trading."))
        add(fishDetectionWindow:AddLabel("Leave empty if you're first in queue."))

        -- Queue Status Section
        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Queue Status â”â”â”â”â”â”"))

        local queueModeText = isQueueModeEnabled and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"
        add(fishDetectionWindow:AddLabel("Queue Mode: " .. queueModeText))

        if isQueueModeEnabled then
            if selectedWaitForPlayer then
                add(fishDetectionWindow:AddLabel(string.format("â³ Waiting for: %s", selectedWaitForPlayer.Name)))
            else
                add(fishDetectionWindow:AddLabel("ðŸ“ My Position: First in queue"))
            end

            add(fishDetectionWindow:AddLabel(string.format("â±ï¸ Timeout: %d seconds", queueTimeout)))
            add(fishDetectionWindow:AddLabel(string.format("ðŸ”‘ Signal Keyword: '%s'", queueSignalKeyword)))
            add(fishDetectionWindow:AddLabel("ðŸ’¡ Status: " .. queueStatus))

            if waitingForPlayer then
                add(fishDetectionWindow:AddLabel(string.format("â³ Currently waiting for: %s", waitingForPlayer)))

                if timeoutStartTime > 0 then
                    local elapsed = os.time() - timeoutStartTime
                    local remaining = queueTimeout - elapsed
                    add(fishDetectionWindow:AddLabel(string.format("â±ï¸ Time remaining: %d seconds", math.max(0, remaining))))
                end
            end
        end

        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Configuration â”â”â”â”â”â”"))

        -- Timeout Input
        add(fishDetectionWindow:AddLabel("Timeout duration in seconds:"))
        local timeoutInput, timeoutFrame = fishDetectionWindow:AddNumberInput("Timeout (e.g., 300)", queueTimeout, function(value)
            queueTimeout = math.max(30, math.floor(value))
            print(string.format("[Queue Config] Timeout set to: %d seconds", queueTimeout))
            updateDisplay()
        end)

        -- Player Selection Section
        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Select Player to Wait For â”â”â”â”â”â”"))
        add(fishDetectionWindow:AddLabel("Choose which player you want to wait for 'DONE' signal from."))
        add(fishDetectionWindow:AddLabel("Leave unselected if you're first in queue."))

        if selectedWaitForPlayer then
            add(fishDetectionWindow:AddLabel("â³ Waiting for: " .. selectedWaitForPlayer.Name))
            add(fishDetectionWindow:AddButton("âŒ Clear Selected Player", function()
                selectedWaitForPlayer = nil
                print("[Queue Config] Cleared selected player - now first in queue")
                updateDisplay()
            end))
        else
            add(fishDetectionWindow:AddLabel("â³ Waiting for: None (First in queue)"))
        end

        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Available Players â”â”â”â”â”â”"))
        local players = Players:GetPlayers()
        if #players <= 1 then
            add(fishDetectionWindow:AddLabel("No other players in the server."))
        else
            for _, player in ipairs(players) do
                if player ~= LocalPlayer then
                    local buttonLabel = player.Name
                    if selectedWaitForPlayer and selectedWaitForPlayer.UserId == player.UserId then
                        buttonLabel = "âœ… " .. buttonLabel
                    end

                    add(fishDetectionWindow:AddButton(buttonLabel, function()
                        selectedWaitForPlayer = {
                            Name = player.Name,
                            UserId = player.UserId
                        }
                        print(string.format("[Queue Config] Selected to wait for: %s", player.Name))
                        updateDisplay()
                    end))
                end
            end
        end

        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” Controls â”â”â”â”â”â”"))

        if isQueueModeEnabled then
            add(fishDetectionWindow:AddButton("ðŸ›‘ Disable Queue Mode", function()
                isQueueModeEnabled = false
                queueStatus = "Idle"
                waitingForPlayer = nil

                -- Disconnect listeners
                if chatMessageConnection then
                    chatMessageConnection:Disconnect()
                    chatMessageConnection = nil
                end

                stopQueueTimeout()

                print("[Queue] âŒ Queue mode disabled!")
                updateDisplay()
            end))

            -- Force Start button only shows when waiting
            if queueStatus == "Waiting" then
                add(fishDetectionWindow:AddButton("ðŸš€ Force Start Trade (Skip Wait)", function()
                    print("[Queue] ðŸš€ Force starting trade (skipping wait)...")
                    stopQueueTimeout()

                    if chatMessageConnection then
                        chatMessageConnection:Disconnect()
                        chatMessageConnection = nil
                    end

                    queueStatus = "Idle"
                    waitingForPlayer = nil
                    updateDisplay()

                    -- User can manually go to Auto Trade tab and click Start
                    print("[Queue] â„¹ï¸ Go to Auto Trade tab and click 'Start Auto Trade'")
                end))
            end

            add(fishDetectionWindow:AddButton("ðŸ”§ Test Send DONE Signal", function()
                sendDoneSignal()
            end))

        else
            add(fishDetectionWindow:AddButton("âœ… Enable Queue Mode", function()
                isQueueModeEnabled = true
                queueStatus = "Idle"
                print("[Queue] âœ… Queue mode enabled!")

                if selectedWaitForPlayer then
                    print(string.format("[Queue] ðŸ‘‚ Will wait for: %s", selectedWaitForPlayer.Name))
                    -- Start listening for DONE signal immediately
                    setupQueueChatListener()
                else
                    print("[Queue] â„¹ï¸ First in queue - no wait needed")
                end

                updateDisplay()
            end))
        end

        add(fishDetectionWindow:AddLabel("â”â”â”â”â”â” How It Works â”â”â”â”â”â”"))
        add(fishDetectionWindow:AddLabel(""))
        add(fishDetectionWindow:AddLabel("1ï¸âƒ£ WITHOUT Queue Mode (Normal):"))
        add(fishDetectionWindow:AddLabel("   â€¢ Go to Auto Trade tab"))
        add(fishDetectionWindow:AddLabel("   â€¢ Click 'Start Auto Trade'"))
        add(fishDetectionWindow:AddLabel("   â€¢ After done â†’ Auto chat 'DONE'"))
        add(fishDetectionWindow:AddLabel(""))
        add(fishDetectionWindow:AddLabel("2ï¸âƒ£ WITH Queue Mode (Wait for signal):"))
        add(fishDetectionWindow:AddLabel("   Player 1 (First):"))
        add(fishDetectionWindow:AddLabel("   â€¢ DON'T select anyone in Queue tab"))
        add(fishDetectionWindow:AddLabel("   â€¢ Enable Queue Mode"))
        add(fishDetectionWindow:AddLabel("   â€¢ Go to Auto Trade â†’ Start trading"))
        add(fishDetectionWindow:AddLabel(""))
        add(fishDetectionWindow:AddLabel("   Player 2 (Second):"))
        add(fishDetectionWindow:AddLabel("   â€¢ SELECT Player 1 in Queue tab"))
        add(fishDetectionWindow:AddLabel("   â€¢ Enable Queue Mode (auto-listens)"))
        add(fishDetectionWindow:AddLabel("   â€¢ When P1 says 'DONE' â†’ Auto-start trade"))
        add(fishDetectionWindow:AddLabel(""))
        add(fishDetectionWindow:AddLabel("   Player 3 (Third):"))
        add(fishDetectionWindow:AddLabel("   â€¢ SELECT Player 2 in Queue tab"))
        add(fishDetectionWindow:AddLabel("   â€¢ Enable Queue Mode (auto-listens)"))
        add(fishDetectionWindow:AddLabel("   â€¢ When P2 says 'DONE' â†’ Auto-start trade"))

    elseif currentTab == "Enchant" then
        local order = 1
        local function add(inst) inst.LayoutOrder = order; order = order + 1; return inst end

        add(fishDetectionWindow:AddLabel("âœ¨ Auto Enchant System"))
        add(fishDetectionWindow:AddLabel("Auto teleport + Auto equip + Auto enchant!"))

        local statusColor = isAutoEnchantOn and "ðŸŸ¢ RUNNING" or "ðŸ”´ STOPPED"
        add(fishDetectionWindow:AddLabel("Status: " .. statusColor))

        local targetEnchantName = "Unknown"
        for name, id in pairs(enchantDatabase) do
            if id == targetEnchantID then
                targetEnchantName = name
                break
            end
        end

        add(fishDetectionWindow:AddLabel("ðŸŽ¯ Target: " .. targetEnchantName .. " (ID: " .. targetEnchantID .. ")"))
        add(fishDetectionWindow:AddLabel(string.format("ðŸ”„ Attempts: %d", enchantAttempts)))

        if enchantFound then
            add(fishDetectionWindow:AddLabel("âœ… Status: Target enchant FOUND!"))
            add(fishDetectionWindow:AddLabel(string.format("ðŸŽ‰ Success after %d attempts!", enchantAttempts)))
        elseif isAutoEnchantOn then
            add(fishDetectionWindow:AddLabel("â³ Status: Searching for target..."))
            add(fishDetectionWindow:AddLabel("ðŸ”„ Loop is running continuously"))
        else
            add(fishDetectionWindow:AddLabel("ðŸ’¤ Status: Idle - Ready to start"))
        end

        add(fishDetectionWindow:AddLabel("Select Target Enchant:"))

        local enchantNames = {}
        for name, _ in pairs(enchantDatabase) do
            table.insert(enchantNames, name)
        end
        table.sort(enchantNames)

        for _, enchantName in ipairs(enchantNames) do
            local enchantId = enchantDatabase[enchantName]
            local isSelected = (enchantId == targetEnchantID)
            local buttonText = isSelected and ("âœ… " .. enchantName) or ("âšª " .. enchantName)

            add(fishDetectionWindow:AddButton(buttonText, function()
                targetEnchantID = enchantId
                enchantFound = false
                enchantAttempts = 0
                print(string.format("[Auto Enchant] Target changed to: %s (ID: %d)", enchantName, enchantId))
                updateDisplay()
            end))
        end

        if isAutoEnchantOn then
            add(fishDetectionWindow:AddButton("ðŸ›‘ Stop Auto Enchant", function()
                stopAutoEnchant()
                updateDisplay()
            end))
        else
            add(fishDetectionWindow:AddButton("ðŸš€ Start Auto Enchant (Auto TP)", function()
                isAutoEnchantOn = true
                startAutoEnchant()
                updateDisplay()
            end))
        end

        add(fishDetectionWindow:AddButton("ðŸ“ Teleport to Enchant Altar", function()
            teleportToEnchantAltar()
        end))

        add(fishDetectionWindow:AddButton("ðŸ”§ Manual Enchant Once", function()
            task.spawn(function()
                print("[Auto Enchant] Manual enchant started...")
                local equipped = autoEquipEnchantStone()
                if equipped then
                    activateEnchantingAltar()
                end
            end)
        end))

        add(fishDetectionWindow:AddButton("ðŸ” Test Enchant Stone Detection", function()
            local uuid = findEnchantStoneUUID()
            if uuid then
                print("[Auto Enchant] âœ… Enchant stone found with UUID:", uuid)
            else
                print("[Auto Enchant] âŒ No enchant stone found in inventory!")
            end
        end))

        add(fishDetectionWindow:AddButton("ðŸ”„ Reset Attempt Counter", function()
            enchantAttempts = 0
            enchantFound = false
            print("[Auto Enchant] Attempt counter reset!")
            updateDisplay()
        end))
    end
end

local function initializeFishDetector()
    LightweightInventory.start()
    task.wait(3)

    fishDetectionWindow = FishDetectorLib.CreateWindow("ðŸŸ Fish & Trade v2.0 - QUEUE SYSTEM")
    updateDisplay()

    -- Event Listeners for Auto Trade
    pcall(function()
        local TextNotificationEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net:WaitForChild("RE/TextNotification")
        TextNotificationEvent.OnClientEvent:Connect(function(data)
            if not isAutoTrading or not fishDetectionWindow or not fishDetectionWindow._screenGui.Enabled then return end

            if data and data.Text then
                if string.find(data.Text, "Trade completed!") then
                    -- Trade berhasil, increment traded fish count
                    local tradedFish = tradeQueue[currentTradeIndex]
                    local fishValue = tradedFish and tradedFish.price or 0

                    tradedFishCount = tradedFishCount + 1
                    tradedFishTotalValue = tradedFishTotalValue + fishValue
                    autoTradeStatus = string.format("âœ… Trade %d/%d successful! (+%s C$)", tradedFishCount, #tradeQueue, formatPrice(fishValue))
                    updateDisplay()

                    -- Move to next fish
                    currentTradeIndex = currentTradeIndex + 1
                    currentRetryCount = 0
                    task.delay(4, processNextTrade)

                elseif string.find(data.Text, "Trade was declined") or string.find(data.Text, "cancelled") or string.find(data.Text, "failed") then
                    -- Trade declined/cancelled/failed
                    if currentRetryCount < MAX_RETRY_ATTEMPTS then
                        currentRetryCount = currentRetryCount + 1
                        autoTradeStatus = string.format("âš ï¸ Trade declined. Retrying... (%d/%d)", currentRetryCount, MAX_RETRY_ATTEMPTS)
                        updateDisplay()
                        task.delay(3, processNextTrade) -- Retry sama fish
                    else
                        -- Max retries reached, skip this fish
                        autoTradeStatus = string.format("âŒ Trade failed after %d attempts. Skipping...", MAX_RETRY_ATTEMPTS)
                        updateDisplay()
                        task.wait(2)
                        currentTradeIndex = currentTradeIndex + 1
                        currentRetryCount = 0
                        processNextTrade() -- Move to next fish
                    end
                end
            end
        end)
    end)

    UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if gameProcessedEvent or not fishDetectionWindow._screenGui.Enabled or currentTab ~= "Fish" or #displayedFish == 0 then return end

        if input.KeyCode == Enum.KeyCode.Left or input.KeyCode == Enum.KeyCode.A then
            if currentIndex > 1 then currentIndex = currentIndex - 1; updateDisplay() end
        elseif input.KeyCode == Enum.KeyCode.Right or input.KeyCode == Enum.KeyCode.D then
            if currentIndex < #displayedFish then currentIndex = currentIndex + 1; updateDisplay() end
        elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.Space then
            local displayItem = displayedFish[currentIndex]
            if displayItem then
                local originalIndex = displayItem.originalIndex
                if selectedFishIndices[originalIndex] then
                    selectedFishIndices[originalIndex] = nil
                else
                    selectedFishIndices[originalIndex] = true
                end
                updateDisplay()
            end
        end
    end)

    print("ðŸŸ Fish & Trade v2.0 - QUEUE SYSTEM initialized!")
    print("[Queue] ðŸ“¢ Queue System ready! Use â±ï¸ Queue tab to configure.")
end

_G.showFishDetector = function()
    if fishDetectionWindow then fishDetectionWindow:Toggle(true)
    else initializeFishDetector() end
end
_G.hideFishDetector = function()
    if fishDetectionWindow then fishDetectionWindow:Toggle(false) end
end
_G.detectFish = function() detectFish(); updateDisplay() end
_G.getDetectedFish = function() return detectedFish end
_G.getSelectedFish = function()
    local selectedFish = {}
    for index, _ in pairs(selectedFishIndices) do
        if detectedFish[index] then table.insert(selectedFish, detectedFish[index]) end
    end
    return selectedFish
end
_G.clearAllSelections = function() selectedFishIndices = {}; updateDisplay() end
_G.selectAllFish = function()
    for i = 1, #detectedFish do selectedFishIndices[i] = true end
    updateDisplay()
end
_G.stopFishDetectorInventory = function() LightweightInventory.stop() end
_G.startFishDetectorInventory = function() LightweightInventory.start() end

task.wait(2)
initializeFishDetector()
