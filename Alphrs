--[[
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    AUTO FISHING + INVENTORY SYSTEM v2.0

    Features:
    - Auto Fishing with Toggle ON/OFF
    - Custom Success Delay
    - Inventory Detection (Fish & Items)
    - WindUI Integration

    Structure:
    1. DEPENDENCIES & SETUP
    2. AUTO FARM MODULE
    3. INVENTORY MODULE
    4. UI MODULE
    5. MAIN EXECUTION

    Usage:
    loadstring(readfile("auto_farm_v2_with_inventory.lua"))()
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]

print(string.rep("=", 80))
print("ğŸš€ AUTO FISHING + INVENTORY SYSTEM v2.0")
print(string.rep("=", 80))
print("\nâ³ Loading modules...\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 1: DEPENDENCIES & SETUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    This section handles all service references and initial setup.
    DO NOT MODIFY unless you need to add new services.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Global State Variables
_G.AUTO_FARM_ENABLED = false
_G.FARM_SUCCESS_DELAY = 1
_G.AUTO_ARTIFACT_ENABLED = false  -- Auto Artifact state
_G.AUTO_SELL_ENABLED = false      -- Auto Sell state
_G.AUTO_SELL_DELAY = 60           -- Auto Sell delay in seconds (default 60s)
_G.AUTO_ELEMENT_ENABLED = false   -- Auto Element state
_G.AUTO_ELEMENT_FARM_ENABLED = false  -- Auto Farm (Element Tab) state
_G.ELEMENT_FARM_WAIT = 1          -- Custom wait before complete (default 1s)
_G.ELEMENT_FARM_AFTER_COMPLETE_WAIT = 1  -- Custom wait after complete before loop restart (default 1s)
_G.AUTO_WEATHER_ENABLED = false   -- Auto Weather state
_G.WEATHER_PURCHASE_DELAY = 32    -- Delay between weather purchase cycles (default 32s)

print("âœ… Services loaded")

-- Required Modules
local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
local VendorUtility = require(ReplicatedStorage.Shared.VendorUtility)
local Replion = require(ReplicatedStorage.Packages.Replion)
local PlayerData = Replion.Client:WaitReplion("Data")

print("âœ… Game modules loaded")

-- Network Events
local Net = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net
local EquipToolEvent = Net["RE/EquipToolFromHotbar"]
local ChargeEvent = Net["RF/ChargeFishingRod"]
local RequestEvent = Net["RF/RequestFishingMinigameStarted"]
local CompletedEvent = Net["RE/FishingCompleted"]
local CancelEvent = Net["RF/CancelFishingInputs"]
local EquipItemEvent = Net["RE/EquipItem"]

print("âœ… Network events loaded\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 2: AUTO FARM MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    Auto Farm Module - Main fishing automation logic

    EDIT START: Line below this marker
    EDIT END: Before next section marker

    Key Functions:
    - startReelIntermissionLoop() - Start fishing animation
    - stopReelIntermissionLoop() - Stop fishing animation
    - runMainLoop() - Main fishing cycle
]]

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO FARM: Animation System
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local AnimationController = require(ReplicatedStorage.Controllers.AnimationController)
local Animations = require(ReplicatedStorage.Modules.Animations)

AnimationController:Init()
AnimationController:Start()
task.wait(2)

local reelIntermissionAnim = nil
for animName, animData in pairs(Animations) do
    if not animData.Disabled and animName:lower():find("reelintermission") then
        reelIntermissionAnim = animName
        print("âœ… Animation: " .. animName)
        break
    end
end

local animationRunning = false
local animationThread = nil

local function startReelIntermissionLoop()
    if not reelIntermissionAnim then return end
    animationRunning = true
    if animationThread then task.cancel(animationThread) end

    animationThread = task.spawn(function()
        while animationRunning do
            pcall(function()
                AnimationController:PlayAnimation(reelIntermissionAnim, false)
            end)
            task.wait(0.01)
        end
    end)
end

local function stopReelIntermissionLoop()
    animationRunning = false
    if animationThread then
        task.cancel(animationThread)
        animationThread = nil
    end
    if reelIntermissionAnim then
        pcall(function()
            AnimationController:StopAnimation(reelIntermissionAnim)
        end)
    end
end

_G.StopReelIntermissionLoop = stopReelIntermissionLoop

print("âœ… Animation system ready")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO FARM: FishCaught Path Deletion
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function deleteFishCaughtPath()
    pcall(function()
        local playerGui = player:WaitForChild("PlayerGui")
        if playerGui:FindFirstChild("FishCaught") then
            playerGui.FishCaught:Destroy()
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(0.5)
        deleteFishCaughtPath()
    end
end)

print("âœ… FishCaught deletion active")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO FARM: Core Fishing Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function equip_tool()
    EquipToolEvent:FireServer(1)
end

function charge_rod()
    ChargeEvent:InvokeServer(nil, nil, nil, time())
end

function request_fishing()
    local success, result = RequestEvent:InvokeServer(math.random(), math.random(), time())
    return success, result
end

function fishing_completed()
    CompletedEvent:FireServer()
end

function cancel_inputs_bypass()
    task.spawn(function()
        CancelEvent:InvokeServer()
    end)
end

print("âœ… Fishing functions loaded")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO FARM: Main Loop
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_G.MAIN_LOOP_RUNNING = false

function runMainLoop()
    if _G.MAIN_LOOP_RUNNING then
        print("âš ï¸ Main loop already running!")
        return
    end

    _G.MAIN_LOOP_RUNNING = true

    print(string.rep("=", 70))
    print("ğŸš€ AUTO FISHING LOOP - STARTING")
    print(string.rep("=", 70) .. "\n")

    local cycleCount = 0
    local successCount = 0

    while _G.MAIN_LOOP_RUNNING do
        -- Wait for farm to be enabled
        while not _G.AUTO_FARM_ENABLED and _G.MAIN_LOOP_RUNNING do
            task.wait(0.5)
        end

        if not _G.MAIN_LOOP_RUNNING then break end
        if not _G.AUTO_FARM_ENABLED then continue end

        cycleCount = cycleCount + 1

        -- Fishing cycle
        equip_tool()
        charge_rod()
        task.wait(0.01)

        local success, result = request_fishing()

        if success then
            successCount = successCount + 1
            print(string.format("[Cycle #%d] âœ… Request SUCCEEDED. Completing after %.2fs...", cycleCount, _G.FARM_SUCCESS_DELAY))
            task.wait(_G.FARM_SUCCESS_DELAY)
            fishing_completed()
        else
            print(string.format("[Cycle #%d] âŒ Request failed.", cycleCount))
        end

        task.wait(0.2)
        cancel_inputs_bypass()
        task.wait(0.01)

        -- Stats every 10 cycles
        if cycleCount % 10 == 0 then
            local successRate = (successCount / cycleCount) * 100
            print(string.format("\nğŸ“Š [STATS] Cycles: %d | Success: %d (%.1f%%) | Farm: %s\n",
                cycleCount,
                successCount,
                successRate,
                _G.AUTO_FARM_ENABLED and "ğŸŸ¢ ON" or "ğŸ”´ OFF"
            ))
        end
    end

    -- Cleanup
    print("\n" .. string.rep("=", 70))
    print("ğŸ›‘ AUTO FISHING LOOP STOPPED")
    print(string.rep("=", 70))
    if cycleCount > 0 then
        local finalRate = (successCount / cycleCount) * 100
        print(string.format("\nğŸ“Š FINAL: %d cycles | %d success (%.1f%%)\n", cycleCount, successCount, finalRate))
    end

    stopReelIntermissionLoop()
    _G.MAIN_LOOP_RUNNING = false
end

print("âœ… Auto farm module ready\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 2.5: AUTO ARTIFACT MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    Auto Artifact Module - Automatic artifact collection from 4 temples

    Features:
    - Sequential temple farming (Temple 1 â†’ 2 â†’ 3 â†’ 4)
    - Auto-favorite artifacts to prevent auto-sell
    - Webhook notifications for each artifact found
    - Automatic teleportation between temples
    - Inventory-based detection system

    Key Functions:
    - AutoArtifact.initialize() - Start the system
    - AutoArtifact.startArtifactChecker() - Main checker loop
    - AutoArtifact.hasArtifactInInventory() - Check for artifacts
    - AutoArtifact.favoriteArtifact() - Auto-favorite found artifacts
]]

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ARTIFACT: State Variables
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local isAutoArtifactOn = false
local artifactCurrentTemple = 1
local artifactCollected = {false, false, false, false}

-- Skip toggles for each artifact (user can manually mark as "already obtained")
local artifactSkipToggles = {
    [1] = false, -- Hourglass Diamond Artifact
    [2] = false, -- Arrow Artifact
    [3] = false, -- Diamond Artifact
    [4] = false  -- Crescent Artifact
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ARTIFACT: Temple Configuration
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local ARTIFACT_CONFIG = {
    -- Temple 1: Hourglass Diamond Artifact
    {
        templeName = "Temple 1",
        targetArtifact = "Hourglass Diamond Artifact",
        cframe = CFrame.new(1490.12305, 6.62499952, -850.539307, -0.982308805, -4.67861128e-09, -0.187268242, -7.57854224e-09, 1, 1.47694985e-08, 0.187268242, 1.59274283e-08, -0.982308805)
    },
    -- Temple 2: Arrow Artifact
    {
        templeName = "Temple 2",
        targetArtifact = "Arrow Artifact",
        cframe = CFrame.new(883.964233, 6.62499952, -360.91275, -0.128746182, 9.21072107e-09, 0.991677582, -4.92979968e-09, 1, -9.92803972e-09, -0.991677582, -6.16696871e-09, -0.128746182)
    },
    -- Temple 3: Diamond Artifact
    {
        templeName = "Temple 3",
        targetArtifact = "Diamond Artifact",
        cframe = CFrame.new(1836.77136, 6.62499952, -288.573303, 0.25269559, 7.76984699e-09, -0.967545807, 3.12285877e-08, 1, 1.61864921e-08, 0.967545807, -3.43053443e-08, 0.25269559)
    },
    -- Temple 4: Crescent Artifact
    {
        templeName = "Temple 4",
        targetArtifact = "Crescent Artifact",
        cframe = CFrame.new(1405.67358, 6.17587185, 119.126236, -0.951030135, -6.02376886e-08, 0.309098154, -8.03642095e-08, 1, -5.23817469e-08, -0.309098154, -7.4657045e-08, -0.951030135)
    }
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ARTIFACT: Inventory Background System
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local InventoryBackgroundSystem = {}
do
    -- Keep inventory tiles loaded in background for artifact detection
    local inventoryController = nil
    local originalDestroyTiles = nil
    local isInventoryHooked = false
    local isLoadingInventory = false

    -- Get InventoryController module
    local function getInventoryController()
        if inventoryController then return inventoryController end

        local success, result = pcall(function()
            local controllers = ReplicatedStorage:WaitForChild("Controllers", 5)
            local invModule = controllers:WaitForChild("InventoryController", 5)
            return require(invModule)
        end)

        if success then
            inventoryController = result
            return inventoryController
        end

        return nil
    end

    -- Hook DestroyTiles to prevent inventory from being destroyed
    local function hookInventoryController()
        if isInventoryHooked then return true end

        local ctrl = getInventoryController()
        if not ctrl then
            warn("[Inventory Background] Failed to get InventoryController")
            return false
        end

        -- Backup original DestroyTiles function
        originalDestroyTiles = ctrl.DestroyTiles

        -- Override with empty function to prevent destruction
        ctrl.DestroyTiles = function()
            -- Do nothing - keep tiles alive
            return
        end

        isInventoryHooked = true
        print("[Inventory Background] âœ… Hooked DestroyTiles successfully")
        return true
    end

    -- Refresh inventory tiles without opening GUI
    local function refreshInventoryTiles(onCompleteCallback)
        if isLoadingInventory then return end
        isLoadingInventory = true

        local ctrl = getInventoryController()
        if ctrl and ctrl.InventoryStateChanged then
            pcall(function()
                -- Fire state change to refresh tiles
                ctrl.InventoryStateChanged:Fire("Items")
            end)
        end

        task.wait(0.1)
        if onCompleteCallback then
            pcall(onCompleteCallback)
        end
        isLoadingInventory = false
    end

    -- Initial load of inventory tiles (opens GUI briefly then hides)
    local function initialLoadInventoryTiles(onCompleteCallback)
        if isLoadingInventory then return end
        isLoadingInventory = true

        local ctrl = getInventoryController()
        if not ctrl then
            warn("[Inventory Background] InventoryController not available")
            isLoadingInventory = false
            return
        end

        local playerGui = player:WaitForChild("PlayerGui")
        local inventoryGUI = playerGui:FindFirstChild("Inventory")
        local mainFrame = inventoryGUI and inventoryGUI:FindFirstChild("Main")

        if not mainFrame then
            warn("[Inventory Background] Inventory GUI not found")
            isLoadingInventory = false
            return
        end

        -- Save previous state
        local previousEnabled = inventoryGUI.Enabled
        local previousVisible = mainFrame.Visible

        -- Temporarily show inventory to load tiles
        inventoryGUI.Enabled = true
        mainFrame.Visible = true
        task.wait(0.2)

        -- Set to Items category to load artifact tiles
        pcall(function()
            if ctrl.SetPage then ctrl.SetPage(ctrl, "Items") end
            if ctrl.SetCategory then ctrl.SetCategory(ctrl, "Items") end
            if ctrl.InventoryStateChanged then
                ctrl.InventoryStateChanged:Fire("Items")
            end
        end)

        task.wait(0.5)

        -- Restore previous state (hide GUI again)
        inventoryGUI.Enabled = previousEnabled
        mainFrame.Visible = previousVisible

        print("[Inventory Background] âœ… Initial inventory tiles loaded")

        if onCompleteCallback then
            pcall(onCompleteCallback)
        end
        isLoadingInventory = false
    end

    -- Public function to start the background inventory system
    function InventoryBackgroundSystem.start(onRefreshCallback)
        if isInventoryHooked then
            print("[Inventory Background] âš ï¸ Already initialized")
            return
        end

        print("[Inventory Background] ğŸš€ Starting background inventory system...")

        task.spawn(function()
            -- Hook the controller first
            if hookInventoryController() then
                task.wait(1)

                -- Initial load of tiles
                initialLoadInventoryTiles(onRefreshCallback)

                -- Setup auto-refresh on inventory close
                pcall(function()
                    local GuiControl = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("GuiControl"))
                    local invGUI = player.PlayerGui:FindFirstChild("Inventory")

                    GuiControl.GuiUnfocusedSignal:Connect(function(closedGui)
                        if closedGui == invGUI then
                            -- Refresh tiles when inventory closes
                            task.delay(0.5, function()
                                refreshInventoryTiles(onRefreshCallback)
                            end)
                        end
                    end)

                    print("[Inventory Background] âœ… Auto-refresh on close enabled")
                end)

                -- Setup refresh on fish caught
                pcall(function()
                    local fishCaughtEvent = Net["RE/FishCaught"]
                    if fishCaughtEvent then
                        fishCaughtEvent.OnClientEvent:Connect(function()
                            task.delay(1, function()
                                refreshInventoryTiles(onRefreshCallback)
                            end)
                        end)
                        print("[Inventory Background] âœ… Auto-refresh on fish caught enabled")
                    end
                end)

                print("[Inventory Background] âœ… Background inventory system active")
            else
                warn("[Inventory Background] âŒ Failed to hook InventoryController")
            end
        end)
    end

    -- Public function to manually refresh tiles
    function InventoryBackgroundSystem.refresh(callback)
        refreshInventoryTiles(callback)
    end
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ARTIFACT: Main Module
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local AutoArtifact = {}
do
    local HttpService = game:GetService("HttpService")

    -- Webhook URL (optional - set to nil if you don't want webhooks)
    local WEBHOOK_URL = nil -- Change to your webhook URL if needed

    -- Use already loaded modules from SECTION 1
    local FavoriteItemEvent = Net["RE/FavoriteItem"]

    -- Function to get artifact UUID from PlayerData inventory
    function AutoArtifact.getArtifactUUID(artifactName)
        if not PlayerData then return nil end

        local success, result = pcall(function()
            local inventoryItems = PlayerData:GetExpect("Inventory").Items
            for _, item in ipairs(inventoryItems) do
                local itemData = ItemUtility:GetItemData(item.Id)
                if itemData and itemData.Data.Name then
                    local itemName = itemData.Data.Name
                    -- Exact match - case-insensitive
                    if itemName:lower() == artifactName:lower() then
                        return item.UUID, itemName
                    end
                end
            end
            return nil
        end)

        if success and result then
            return result
        else
            return nil
        end
    end

    -- Function to favorite an artifact using UUID
    function AutoArtifact.favoriteArtifact(artifactUUID, artifactName)
        if not artifactUUID then
            warn("[Auto Artifact] Cannot favorite - UUID is nil")
            return false
        end

        local success = pcall(function()
            FavoriteItemEvent:FireServer(artifactUUID)
        end)

        if success then
            print(string.format("[Auto Artifact] â­ Favorited: %s", artifactName))
            return true
        else
            warn(string.format("[Auto Artifact] âŒ Failed to favorite: %s", artifactName))
            return false
        end
    end

    -- Check if an item is already favorited
    function AutoArtifact.isItemFavorited(itemUUID)
        if not PlayerData then return false end

        local success, result = pcall(function()
            local inventoryItems = PlayerData:GetExpect("Inventory").Items
            for _, item in ipairs(inventoryItems) do
                if item.UUID == itemUUID then
                    return item.Favorited == true
                end
            end
            return false
        end)

        return success and result or false
    end

    -- Function to auto-favorite all artifacts in inventory
    function AutoArtifact.autoFavoriteAllArtifacts()
        local artifactNames = {
            "Arrow Artifact",
            "Crescent Artifact",
            "Diamond Artifact",
            "Hourglass Diamond Artifact"
        }

        local favorited = 0
        local skipped = 0

        for _, artifactName in ipairs(artifactNames) do
            local uuid, fullName = AutoArtifact.getArtifactUUID(artifactName)
            if uuid then
                -- Check if already favorited
                if AutoArtifact.isItemFavorited(uuid) then
                    skipped = skipped + 1
                else
                    task.wait(0.5)
                    local success = AutoArtifact.favoriteArtifact(uuid, fullName or artifactName)
                    if success then
                        favorited = favorited + 1
                    end
                end
            end
        end

        if favorited > 0 then
            print(string.format("[Auto Artifact] â­ Favorited %d new artifacts", favorited))
        end
        if skipped > 0 then
            print(string.format("[Auto Artifact] â­ï¸ Skipped %d already favorited", skipped))
        end

        return favorited
    end

    -- Check if artifact exists in inventory (GUI-based check)
    function AutoArtifact.hasArtifactInInventory(artifactName)
        local playerGui = player:FindFirstChild("PlayerGui")
        local invContainer = playerGui and playerGui:FindFirstChild("Inventory")
        invContainer = invContainer and invContainer:FindFirstChild("Main")
        invContainer = invContainer and invContainer:FindFirstChild("Content")
        invContainer = invContainer and invContainer:FindFirstChild("Pages")
        invContainer = invContainer and invContainer:FindFirstChild("Inventory")

        if not invContainer then return false end

        for _, tile in ipairs(invContainer:GetChildren()) do
            if tile.Name == "Tile" and tile:FindFirstChild("ItemName") then
                local itemName = tile.ItemName.Text
                -- Exact match - case-insensitive
                if itemName:lower() == artifactName:lower() then
                    return true, itemName
                end
            end
        end

        return false
    end

    -- Send webhook notification for artifact found
    function AutoArtifact.sendArtifactFoundWebhook(templeName, artifactName, templeNumber)
        if not WEBHOOK_URL or WEBHOOK_URL == "" then return end

        local embed = {
            title = "ğŸº Artifact Found!",
            description = string.format("**%s** collected from **%s**", artifactName, templeName),
            color = 16776960, -- Yellow/Gold color
            fields = {
                { name = "ğŸ‘¤ Player", value = player.Name, inline = true },
                { name = "ğŸ›ï¸ Temple", value = templeName, inline = true },
                { name = "ğŸº Artifact", value = artifactName, inline = true },
                { name = "ğŸ“ Progress", value = string.format("%d/4 Temples Completed", templeNumber), inline = false },
                { name = "ğŸ•’ Time", value = os.date("%H:%M:%S"), inline = false }
            },
            footer = { text = "Auto Artifact System" }
        }

        local payload = { embeds = {embed} }

        pcall(function()
            local req = (syn and syn.request) or http_request
            if req then
                req({
                    Url = WEBHOOK_URL,
                    Method = "POST",
                    Headers = {["Content-Type"] = "application/json"},
                    Body = HttpService:JSONEncode(payload)
                })
            end
        end)
    end

    -- Send webhook notification when all artifacts collected
    function AutoArtifact.sendAllArtifactsCompleteWebhook()
        if not WEBHOOK_URL or WEBHOOK_URL == "" then return end

        local embed = {
            title = "âœ… ALL ARTIFACTS COLLECTED!",
            description = "**All 4 artifacts have been successfully collected!**",
            color = 65280, -- Green color
            fields = {
                { name = "ğŸ‘¤ Player", value = player.Name, inline = true },
                { name = "ğŸ† Status", value = "COMPLETE", inline = true },
                { name = "ğŸº Artifacts", value = "4/4 Collected", inline = true },
                { name = "ğŸ•’ Completed At", value = os.date("%H:%M:%S"), inline = false }
            },
            footer = { text = "Auto Artifact System - Farm Complete!" }
        }

        local payload = { embeds = {embed} }

        pcall(function()
            local req = (syn and syn.request) or http_request
            if req then
                req({
                    Url = WEBHOOK_URL,
                    Method = "POST",
                    Headers = {["Content-Type"] = "application/json"},
                    Body = HttpService:JSONEncode(payload)
                })
            end
        end)
    end

    -- Teleport player to temple location
    function AutoArtifact.teleportToTemple(cframeData)
        local char = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = char:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return false end

        pcall(function()
            humanoidRootPart.CFrame = cframeData
        end)

        return true
    end

    -- Main artifact checker loop
    function AutoArtifact.startArtifactChecker()
        task.spawn(function()
            print("[Auto Artifact] " .. string.rep("=", 60))
            print("[Auto Artifact] ğŸ” Artifact Checker Loop Started!")
            print("[Auto Artifact] " .. string.rep("=", 60))

            local lastCheckLog = 0
            local LOG_INTERVAL = 60 -- Log every 60 seconds

            while isAutoArtifactOn and artifactCurrentTemple <= 4 do
                -- Get current temple config
                local currentConfig = ARTIFACT_CONFIG[artifactCurrentTemple]

                -- Check if this temple is marked as "skip"
                if artifactSkipToggles[artifactCurrentTemple] then
                    print("[Auto Artifact] " .. string.rep("=", 60))
                    print(string.format("[Auto Artifact] â­ï¸ SKIPPED: %s (manually marked)", currentConfig.targetArtifact))
                    print(string.format("[Auto Artifact] ğŸ›ï¸ Temple: %s", currentConfig.templeName))
                    print("[Auto Artifact] " .. string.rep("=", 60))

                    -- Mark as collected and move to next
                    artifactCollected[artifactCurrentTemple] = true
                    artifactCurrentTemple = artifactCurrentTemple + 1

                    if artifactCurrentTemple <= 4 then
                        local nextConfig = ARTIFACT_CONFIG[artifactCurrentTemple]
                        print("[Auto Artifact] " .. string.rep("=", 60))
                        print(string.format("[Auto Artifact] ğŸ“ NEXT: %s", nextConfig.templeName))
                        print(string.format("[Auto Artifact] ğŸ¯ TARGET: %s", nextConfig.targetArtifact))
                        print("[Auto Artifact] " .. string.rep("=", 60))

                        -- Teleport to next temple
                        task.wait(1)
                        AutoArtifact.teleportToTemple(nextConfig.cframe)
                        print("[Auto Artifact] âœ… Teleported to next temple!")
                        task.wait(3)
                    end

                    -- Continue to next iteration
                    task.wait(0.5)
                    continue
                end

                -- Log status every 60 seconds
                if tick() - lastCheckLog >= LOG_INTERVAL then
                    print(string.format("[Auto Artifact] ğŸ” Checking for %s at %s (Temple %d/4)",
                        currentConfig.targetArtifact,
                        currentConfig.templeName,
                        artifactCurrentTemple))
                    lastCheckLog = tick()
                end

                if not artifactCollected[artifactCurrentTemple] then
                    -- Check if target artifact is in inventory
                    local hasArtifact, fullName = AutoArtifact.hasArtifactInInventory(currentConfig.targetArtifact)

                    if hasArtifact then
                        print("[Auto Artifact] " .. string.rep("=", 60))
                        print(string.format("[Auto Artifact] âœ… ARTIFACT FOUND: %s", fullName))
                        print(string.format("[Auto Artifact] ğŸ›ï¸ Location: %s", currentConfig.templeName))
                        print("[Auto Artifact] " .. string.rep("=", 60))

                        -- Mark as collected
                        artifactCollected[artifactCurrentTemple] = true

                        -- Auto-favorite the artifact
                        print("[Auto Artifact] ğŸŒŸ Checking if artifact needs favoriting...")
                        task.wait(1)

                        local artifactUUID, artifactFullName = AutoArtifact.getArtifactUUID(currentConfig.targetArtifact)
                        if artifactUUID then
                            if AutoArtifact.isItemFavorited(artifactUUID) then
                                print(string.format("[Auto Artifact] â­ï¸ '%s' already favorited", artifactFullName or fullName))
                            else
                                print(string.format("[Auto Artifact] ğŸŒŸ Favoriting: %s", artifactFullName or fullName))
                                AutoArtifact.favoriteArtifact(artifactUUID, artifactFullName or fullName)
                            end
                        else
                            warn("[Auto Artifact] âš ï¸ Could not find artifact UUID")
                        end

                        task.wait(1)

                        -- Send webhook notification
                        AutoArtifact.sendArtifactFoundWebhook(
                            currentConfig.templeName,
                            fullName or currentConfig.targetArtifact,
                            artifactCurrentTemple
                        )

                        print("[Auto Artifact] ğŸ“¤ Webhook sent (if configured)")
                        task.wait(2)

                        -- Move to next temple
                        artifactCurrentTemple = artifactCurrentTemple + 1

                        if artifactCurrentTemple <= 4 then
                            local nextConfig = ARTIFACT_CONFIG[artifactCurrentTemple]
                            print("[Auto Artifact] " .. string.rep("=", 60))
                            print(string.format("[Auto Artifact] ğŸ“ NEXT: %s", nextConfig.templeName))
                            print(string.format("[Auto Artifact] ğŸ¯ TARGET: %s", nextConfig.targetArtifact))
                            print("[Auto Artifact] " .. string.rep("=", 60))

                            -- Teleport to next temple
                            task.wait(1)
                            AutoArtifact.teleportToTemple(nextConfig.cframe)
                            print("[Auto Artifact] âœ… Teleported to next temple!")
                            task.wait(3)
                        else
                            -- All artifacts collected!
                            print("[Auto Artifact] " .. string.rep("=", 60))
                            print("[Auto Artifact] ğŸ‰ğŸ‰ğŸ‰ ALL ARTIFACTS COLLECTED! ğŸ‰ğŸ‰ğŸ‰")
                            print("[Auto Artifact] " .. string.rep("=", 60))

                            -- Send completion webhook
                            AutoArtifact.sendAllArtifactsCompleteWebhook()
                            print("[Auto Artifact] ğŸ“¤ Completion webhook sent!")

                            -- Stop the system
                            isAutoArtifactOn = false
                            _G.AUTO_ARTIFACT_ENABLED = false
                            print("[Auto Artifact] âœ… System completed successfully!")
                            break
                        end
                    end
                end

                task.wait(5) -- Check every 5 seconds
            end

            if artifactCurrentTemple > 4 then
                print("[Auto Artifact] " .. string.rep("=", 60))
                print("[Auto Artifact] System stopped - All artifacts collected")
                print("[Auto Artifact] " .. string.rep("=", 60))
            end
        end)
    end

    -- Initialize and start system
    function AutoArtifact.initialize()
        if not isAutoArtifactOn then
            print("[Auto Artifact] âš ï¸ System not enabled")
            return
        end

        print("[Auto Artifact] ğŸš€ Initializing Auto Artifact System...")

        -- Reset state if restarting
        if artifactCurrentTemple > 4 then
            artifactCurrentTemple = 1
            artifactCollected = {false, false, false, false}
            print("[Auto Artifact] ğŸ”„ Reset progress (restarting)")
        end

        -- Auto-favorite any existing artifacts
        task.wait(2)
        AutoArtifact.autoFavoriteAllArtifacts()
        task.wait(1)

        -- Find first temple that is not skipped
        local startTemple = artifactCurrentTemple
        while startTemple <= 4 and artifactSkipToggles[startTemple] do
            print(string.format("[Auto Artifact] â­ï¸ Skipping %s (marked as obtained)", ARTIFACT_CONFIG[startTemple].targetArtifact))
            artifactCollected[startTemple] = true
            startTemple = startTemple + 1
        end

        -- Update current temple
        artifactCurrentTemple = startTemple

        -- Check if all temples are skipped
        if artifactCurrentTemple > 4 then
            print("[Auto Artifact] âš ï¸ All artifacts are marked as skip!")
            print("[Auto Artifact] âš ï¸ Nothing to farm. System will not start.")
            isAutoArtifactOn = false
            _G.AUTO_ARTIFACT_ENABLED = false
            return
        end

        -- Teleport to first non-skipped temple
        local currentConfig = ARTIFACT_CONFIG[artifactCurrentTemple]
        print(string.format("[Auto Artifact] ğŸ“ Starting at %s", currentConfig.templeName))
        print(string.format("[Auto Artifact] ğŸ¯ Target: %s", currentConfig.targetArtifact))

        task.wait(1)
        AutoArtifact.teleportToTemple(currentConfig.cframe)
        print("[Auto Artifact] âœ… Teleported to temple!")
        task.wait(2)

        -- Start the checker loop
        AutoArtifact.startArtifactChecker()
    end
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ARTIFACT: Control Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function startAutoArtifact()
    if isAutoArtifactOn then
        print("âš ï¸ Auto Artifact already enabled!")
        return
    end

    print("\nğŸ¯ Starting Auto Artifact System...")
    isAutoArtifactOn = true
    _G.AUTO_ARTIFACT_ENABLED = true

    -- Start background inventory system first
    task.spawn(function()
        print("[Auto Artifact] ğŸ”„ Initializing background inventory...")
        InventoryBackgroundSystem.start(function()
            -- Callback after inventory refresh
            print("[Auto Artifact] ğŸ“¦ Inventory refreshed")
        end)

        -- Wait for inventory to be ready
        task.wait(3)

        -- Start the artifact system
        AutoArtifact.initialize()
    end)

    print("âœ… Auto Artifact ENABLED\n")
end

local function stopAutoArtifact()
    if not isAutoArtifactOn then
        print("âš ï¸ Auto Artifact already stopped!")
        return
    end

    print("\nğŸ›‘ Stopping Auto Artifact System...")
    isAutoArtifactOn = false
    _G.AUTO_ARTIFACT_ENABLED = false

    print("âœ… Auto Artifact stopped\n")
end

print("âœ… Auto artifact module ready\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 2.6: AUTO SELL MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    Auto Sell Module - Automatic item selling with custom delay

    Key Functions:
    - startAutoSell() - Start auto sell loop
    - stopAutoSell() - Stop auto sell loop
    - runAutoSellLoop() - Main selling loop
]]

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO SELL: State Variables
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local isAutoSellRunning = false

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO SELL: Main Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function runAutoSellLoop()
    if isAutoSellRunning then
        print("âš ï¸ Auto Sell loop already running!")
        return
    end

    isAutoSellRunning = true
    print(string.rep("=", 70))
    print("ğŸ’° AUTO SELL LOOP - STARTING")
    print(string.rep("=", 70) .. "\n")

    local cycleCount = 0
    local sellSuccessCount = 0
    local sellFailCount = 0

    -- Get SellAllItems event
    local SellAllItemsEvent = Net["RF/SellAllItems"]

    while isAutoSellRunning and _G.AUTO_SELL_ENABLED do
        cycleCount = cycleCount + 1

        print(string.format("[Auto Sell #%d] ğŸ’° Attempting to sell all items...", cycleCount))

        -- Invoke sell event
        local success, result = pcall(function()
            return SellAllItemsEvent:InvokeServer()
        end)

        if success then
            if result then
                sellSuccessCount = sellSuccessCount + 1
                print(string.format("[Auto Sell #%d] âœ… Items sold successfully", cycleCount))
            else
                sellFailCount = sellFailCount + 1
                print(string.format("[Auto Sell #%d] âš ï¸ No items to sell or sell failed", cycleCount))
            end
        else
            sellFailCount = sellFailCount + 1
            warn(string.format("[Auto Sell #%d] âŒ Error selling items: %s", cycleCount, tostring(result)))
        end

        -- Stats every 5 cycles
        if cycleCount % 5 == 0 then
            print(string.format("\nğŸ“Š [AUTO SELL STATS] Cycles: %d | Success: %d | Failed: %d | Delay: %ds | Status: %s\n",
                cycleCount,
                sellSuccessCount,
                sellFailCount,
                _G.AUTO_SELL_DELAY,
                _G.AUTO_SELL_ENABLED and "ğŸŸ¢ ON" or "ğŸ”´ OFF"
            ))
        end

        -- Wait for the specified delay
        local delayRemaining = _G.AUTO_SELL_DELAY
        while delayRemaining > 0 and isAutoSellRunning and _G.AUTO_SELL_ENABLED do
            task.wait(1)
            delayRemaining = delayRemaining - 1
        end
    end

    -- Cleanup
    print("\n" .. string.rep("=", 70))
    print("ğŸ›‘ AUTO SELL LOOP STOPPED")
    print(string.rep("=", 70))
    if cycleCount > 0 then
        print(string.format("\nğŸ“Š FINAL STATS: %d cycles | %d success | %d failed\n",
            cycleCount, sellSuccessCount, sellFailCount))
    end

    isAutoSellRunning = false
end

local function startAutoSell()
    if _G.AUTO_SELL_ENABLED then
        print("âš ï¸ Auto Sell already enabled!")
        return
    end

    print("\nğŸ’° Starting Auto Sell...")
    _G.AUTO_SELL_ENABLED = true

    -- Start the auto sell loop
    if not isAutoSellRunning then
        task.spawn(runAutoSellLoop)
    end

    print(string.format("âœ… Auto Sell ENABLED (Delay: %ds)\n", _G.AUTO_SELL_DELAY))
end

local function stopAutoSell()
    if not _G.AUTO_SELL_ENABLED then
        print("âš ï¸ Auto Sell already stopped!")
        return
    end

    print("\nğŸ›‘ Stopping Auto Sell...")
    _G.AUTO_SELL_ENABLED = false

    print("âœ… Auto Sell stopped successfully\n")
end

print("âœ… Auto sell module ready\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 2.7: AUTO ELEMENT MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    Auto Element Module - Automatic element collection

    Key Functions:
    - startAutoElement() - Start auto element system
    - stopAutoElement() - Stop auto element system
    - runAutoElementLoop() - Main element collection loop
]]

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ELEMENT: State Variables
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local isAutoElementRunning = false

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ELEMENT: Location Configuration
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local ELEMENT_LOCATIONS = {
    ["Ancient Jungle"] = CFrame.new(1490.12305, 6.62499952, -850.539307, -0.982308805, -4.67861128e-09, -0.187268242, -7.57854224e-09, 1, 1.47694985e-08, 0.187268242, 1.59274283e-08, -0.982308805),
    ["Sacred Temple"] = CFrame.new(1466.92151, -21.8750591, -622.835693, -0.764787138, 8.14444334e-09, 0.644283056, 2.31097452e-08, 1, 1.4791004e-08, -0.644283056, 2.6201187e-08, -0.764787138)
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ELEMENT: Element Tracker Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function getElementTrackerLabels()
    local success, result = pcall(function()
        local menuRings = workspace:FindFirstChild("!!! MENU RINGS")
        if not menuRings then return nil end

        local elementTracker = menuRings:FindFirstChild("Element Tracker")
        if not elementTracker then return nil end

        local board = elementTracker:FindFirstChild("Board")
        if not board then return nil end

        local gui = board:FindFirstChild("Gui")
        if not gui then return nil end

        local content = gui:FindFirstChild("Content")
        if not content then return nil end

        -- Read Label1 to Label4
        local labels = {}
        for i = 1, 4 do
            local label = content:FindFirstChild("Label" .. i)
            if label and label.Text then
                labels[i] = label.Text
            else
                labels[i] = ""
            end
        end

        return labels
    end)

    if success and result then
        return result
    else
        return nil
    end
end

local function getElementTrackerStatus()
    local labels = getElementTrackerLabels()

    if not labels then
        return "âŒ Error reading tracker"
    end

    local statusText = ""
    for i = 1, 4 do
        if labels[i] and labels[i] ~= "" then
            statusText = statusText .. labels[i]
            if i < 4 then statusText = statusText .. "\n" end
        else
            statusText = statusText .. "Label" .. i .. ": N/A"
            if i < 4 then statusText = statusText .. "\n" end
        end
    end

    return statusText
end

-- Parse quest text to extract location and progress
local function parseQuestText(questText)
    if not questText or questText == "" then
        return nil, nil
    end

    -- Debug: Print raw quest text
    print(string.format("[Debug] Raw quest text: '%s'", questText))

    -- Extract location (e.g., "Ancient Jungle", "Sacred Temple")
    -- Pattern matches: "at [location name] - [percentage]"
    local location = questText:match("at%s+([^%-]+)%s*%-")

    if location then
        -- Trim whitespace
        location = location:match("^%s*(.-)%s*$")
    end

    -- Extract progress percentage (e.g., "0%", "50%", "100%")
    local progress = questText:match("(%d+)%%")

    -- Debug output
    print(string.format("[Debug] Extracted -> Location: '%s', Progress: %s%%",
        location or "nil",
        progress or "nil"))

    return location, tonumber(progress)
end

-- Quest completion tracker (to handle Label2 -> Label3 priority)
local completedQuests = {
    Label2 = false,  -- Track if Label2 was completed
    Label3 = false   -- Track if Label3 was completed
}

-- Check if quest is incomplete (0%)
local function isQuestIncomplete(questText)
    local location, progress = parseQuestText(questText)
    return location ~= nil and progress == 0
end

-- Get target location for incomplete quest
local function getTargetLocation()
    local labels = getElementTrackerLabels()

    if not labels then
        print("[Auto Element] âŒ Failed to get tracker labels")
        return nil, nil
    end

    print(string.rep("-", 70))
    print("[Auto Element] ğŸ” Checking quests for incomplete (0%) status...")

    local label2Location, label2Progress = nil, nil
    local label3Location, label3Progress = nil, nil

    -- Check Label2 (index 2)
    if labels[2] and labels[2] ~= "" then
        print(string.format("[Auto Element] Checking Label2: '%s'", labels[2]))
        label2Location, label2Progress = parseQuestText(labels[2])

        if label2Location and label2Progress ~= nil then
            print(string.format("[Auto Element] Label2 -> Location: '%s', Progress: %d%%", label2Location, label2Progress))

            -- Detect completion: progress went from 0% to >0%
            if label2Progress > 0 and not completedQuests.Label2 then
                completedQuests.Label2 = true
                print(string.format("[Auto Element] âœ… Label2 marked as COMPLETED (%d%%)", label2Progress))
            end

            -- Reset completion flag if quest resets back to 0% (new quest)
            if label2Progress == 0 and completedQuests.Label2 then
                completedQuests.Label2 = false
                print(string.format("[Auto Element] ğŸ”„ Label2 reset to 0%% - marked as NEW QUEST"))
            end
        else
            print("[Auto Element] âš ï¸ Label2 parse failed or no location found")
        end
    else
        print("[Auto Element] âš ï¸ Label2 is empty or not found")
    end

    -- Check Label3 (index 3)
    if labels[3] and labels[3] ~= "" then
        print(string.format("[Auto Element] Checking Label3: '%s'", labels[3]))
        label3Location, label3Progress = parseQuestText(labels[3])

        if label3Location and label3Progress ~= nil then
            print(string.format("[Auto Element] Label3 -> Location: '%s', Progress: %d%%", label3Location, label3Progress))

            -- Detect completion: progress went from 0% to >0%
            if label3Progress > 0 and not completedQuests.Label3 then
                completedQuests.Label3 = true
                print(string.format("[Auto Element] âœ… Label3 marked as COMPLETED (%d%%)", label3Progress))
            end

            -- Reset completion flag if quest resets back to 0% (new quest)
            if label3Progress == 0 and completedQuests.Label3 then
                completedQuests.Label3 = false
                print(string.format("[Auto Element] ğŸ”„ Label3 reset to 0%% - marked as NEW QUEST"))
            end
        else
            print("[Auto Element] âš ï¸ Label3 parse failed or no location found")
        end
    else
        print("[Auto Element] âš ï¸ Label3 is empty or not found")
    end

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- PRIORITY SYSTEM: Label2 first, then Label3 (skip if already completed)
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    -- Priority 1: Label2 at 0% and NOT completed yet
    if label2Location and label2Progress == 0 and not completedQuests.Label2 then
        print(string.format("[Auto Element] ğŸ¯ PRIORITY 1: Label2 at 0%% (not completed) -> %s", label2Location))
        print(string.rep("-", 70))
        return label2Location, "Label2"
    end

    -- Priority 2: Label3 at 0% and NOT completed yet (Label2 either completed or not at 0%)
    if label3Location and label3Progress == 0 and not completedQuests.Label3 then
        if completedQuests.Label2 then
            print(string.format("[Auto Element] ğŸ¯ PRIORITY 2: Label3 at 0%% (Label2 already completed) -> %s", label3Location))
        else
            print(string.format("[Auto Element] ğŸ¯ PRIORITY 2: Label3 at 0%% (Label2 not at 0%%) -> %s", label3Location))
        end
        print(string.rep("-", 70))
        return label3Location, "Label3"
    end

    -- No quest available
    if label2Location and label2Progress == 0 and completedQuests.Label2 then
        print(string.format("[Auto Element] â­ï¸ Label2 at 0%% but already completed, skipping"))
    end

    if label3Location and label3Progress == 0 and completedQuests.Label3 then
        print(string.format("[Auto Element] â­ï¸ Label3 at 0%% but already completed, skipping"))
    end

    print("[Auto Element] â„¹ï¸ No incomplete quests found (all completed or in progress)")
    print(string.rep("-", 70))
    return nil, nil
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ELEMENT: Simplified Auto Farm Functions (Back-to-Back Teleport)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_G.ELEMENT_FARM_LOOP_RUNNING = false

-- Position freeze variables (similar to megalodon lock system)
local elementFarmBodyVelocity = nil
local elementFarmBodyGyro = nil
local elementFarmLockedCFrame = nil
local elementFarmLockConnection = nil
local elementFarmLockActive = false

-- Farming spot CFrame (fixed location)
local ELEMENT_FARM_SPOT = CFrame.new(1459.25, -7.33207703, -1279.56201, -1, 0, 0, 0, -1, 0, 0, 0, 1)

-- Position freeze functions
local function freezeElementPosition()
    local char = player.Character
    if not char then return false end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return false end

    -- Store locked position
    elementFarmLockedCFrame = root.CFrame
    elementFarmLockActive = true

    -- Create BodyVelocity to lock position (smooth, no shaking)
    elementFarmBodyVelocity = Instance.new("BodyVelocity")
    elementFarmBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    elementFarmBodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
    elementFarmBodyVelocity.P = 10000
    elementFarmBodyVelocity.Parent = root

    -- Create BodyGyro to prevent rotation
    elementFarmBodyGyro = Instance.new("BodyGyro")
    elementFarmBodyGyro.CFrame = elementFarmLockedCFrame
    elementFarmBodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    elementFarmBodyGyro.P = 10000
    elementFarmBodyGyro.Parent = root

    -- Minimal position correction (only when very far)
    elementFarmLockConnection = RunService.Heartbeat:Connect(function()
        if not root or not root.Parent or not elementFarmLockActive then
            if elementFarmLockConnection then
                elementFarmLockConnection:Disconnect()
                elementFarmLockConnection = nil
            end
            return
        end

        -- Only correct if drifted extremely far (> 15 studs)
        if (root.Position - elementFarmLockedCFrame.Position).Magnitude > 15 then
            root.CFrame = elementFarmLockedCFrame
            if elementFarmBodyVelocity then
                elementFarmBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)

    print("[Element Farm] ğŸ”’ Position FROZEN at farming spot")
    return true
end

local function unfreezeElementPosition()
    elementFarmLockActive = false
    elementFarmLockedCFrame = nil

    if elementFarmLockConnection then
        elementFarmLockConnection:Disconnect()
        elementFarmLockConnection = nil
    end

    -- Remove BodyVelocity and BodyGyro
    if elementFarmBodyVelocity then
        elementFarmBodyVelocity:Destroy()
        elementFarmBodyVelocity = nil
    end
    if elementFarmBodyGyro then
        elementFarmBodyGyro:Destroy()
        elementFarmBodyGyro = nil
    end

    print("[Element Farm] ğŸ”“ Position UNFROZEN")
end

-- Jump function
local function jumpCharacter()
    local char = player.Character
    if not char then return false end
    local hum = char:FindFirstChild("Humanoid")
    if not hum then return false end

    hum:ChangeState(Enum.HumanoidStateType.Jumping)
    print("[Element Farm] ğŸ¦˜ Character jumped")
    return true
end

local function runElementFarmLoop()
    if _G.ELEMENT_FARM_LOOP_RUNNING then
        print("âš ï¸ Element Farm loop already running!")
        return
    end

    _G.ELEMENT_FARM_LOOP_RUNNING = true

    print(string.rep("=", 70))
    print("ğŸ£ AUTO FARM (ELEMENT TAB) - BACK-TO-BACK TELEPORT MODE")
    print(string.rep("=", 70) .. "\n")

    local cycleCount = 0
    local successCount = 0
    local teleportCount = 0

    while _G.ELEMENT_FARM_LOOP_RUNNING do
        -- Wait for farm to be enabled
        while not _G.AUTO_ELEMENT_FARM_ENABLED and _G.ELEMENT_FARM_LOOP_RUNNING do
            task.wait(0.5)
        end

        if not _G.ELEMENT_FARM_LOOP_RUNNING then break end
        if not _G.AUTO_ELEMENT_FARM_ENABLED then continue end

        cycleCount = cycleCount + 1

        print(string.rep("-", 70))
        print(string.format("[Element Farm #%d] ğŸ”„ Starting back-to-back teleport cycle...", cycleCount))

        -- ===== STEP 1: Teleport to farming spot =====
        local char = player.Character
        if char then
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then
                print(string.format("[Element Farm #%d] ğŸ“ Teleporting to farming spot...", cycleCount))
                root.CFrame = ELEMENT_FARM_SPOT
                teleportCount = teleportCount + 1
                task.wait(0.2)  -- Wait for teleport to settle

                -- ===== STEP 2: Jump once =====
                print(string.format("[Element Farm #%d] ğŸ¦˜ Jumping...", cycleCount))
                jumpCharacter()
                task.wait(0.3)  -- Wait for jump

                -- ===== STEP 3: Freeze position =====
                print(string.format("[Element Farm #%d] ğŸ”’ Freezing position...", cycleCount))
                freezeElementPosition()
                task.wait(0.2)

                -- ===== STEP 4: Charge + Request at frozen location =====
                print(string.format("[Element Farm #%d] âš¡ Charging and requesting at farming spot...", cycleCount))
                equip_tool()
                charge_rod()
                task.wait(0.01)

                local success, result = request_fishing()

                if success then
                    successCount = successCount + 1

                    -- ===== STEP 5: Get current quest location and teleport back BEFORE complete =====
                    print(string.format("[Element Farm #%d] ğŸ” Getting current quest location...", cycleCount))
                    local questLocation, labelSource = getTargetLocation()

                    if questLocation and ELEMENT_LOCATIONS[questLocation] then
                        print(string.format("[Element Farm #%d] ğŸš€ Teleporting BACK to quest location: %s (%s)", cycleCount, questLocation, labelSource))

                        -- Unfreeze FIRST before teleporting back
                        unfreezeElementPosition()
                        task.wait(0.1)

                        -- Teleport back to quest location
                        root.CFrame = ELEMENT_LOCATIONS[questLocation]
                        print(string.format("[Element Farm #%d] âœ… Arrived at %s", cycleCount, questLocation))
                        task.wait(0.2)
                    else
                        print(string.format("[Element Farm #%d] âš ï¸ No active quest found, unfreezing at current location", cycleCount))
                        unfreezeElementPosition()
                    end

                    -- ===== STEP 6: Custom wait AFTER teleport back =====
                    print(string.format("[Element Farm #%d] â³ Waiting %.2fs before complete...", cycleCount, _G.ELEMENT_FARM_WAIT))
                    task.wait(_G.ELEMENT_FARM_WAIT)

                    -- ===== STEP 7: Complete catch at quest location =====
                    print(string.format("[Element Farm #%d] âœ… Completing catch at quest location...", cycleCount))
                    fishing_completed()

                    -- ===== STEP 8: Wait after complete before restarting loop =====
                    print(string.format("[Element Farm #%d] â¸ï¸ Waiting %.2fs after complete before restarting...", cycleCount, _G.ELEMENT_FARM_AFTER_COMPLETE_WAIT))
                    task.wait(_G.ELEMENT_FARM_AFTER_COMPLETE_WAIT)
                    print(string.format("[Element Farm #%d] ğŸ”„ Restarting loop...\n", cycleCount))
                else
                    print(string.format("[Element Farm #%d] âŒ Request failed, cleaning up...", cycleCount))
                    unfreezeElementPosition()
                end
            else
                warn(string.format("[Element Farm #%d] âŒ HumanoidRootPart not found!", cycleCount))
            end
        else
            warn(string.format("[Element Farm #%d] âŒ Character not found!", cycleCount))
        end

        task.wait(0.01)  -- Small delay before next cycle

        -- Stats every 10 cycles
        if cycleCount % 10 == 0 then
            local successRate = (successCount / cycleCount) * 100
            print(string.rep("=", 70))
            print(string.format("ğŸ“Š [ELEMENT FARM STATS]"))
            print(string.format("   Cycles: %d", cycleCount))
            print(string.format("   Success: %d (%.1f%%)", successCount, successRate))
            print(string.format("   Teleports: %d", teleportCount))
            print(string.format("   Wait: %.2fs", _G.ELEMENT_FARM_WAIT))
            print(string.format("   Status: %s", _G.AUTO_ELEMENT_FARM_ENABLED and "ğŸŸ¢ ON" or "ğŸ”´ OFF"))
            print(string.rep("=", 70) .. "\n")
        end
    end

    -- Cleanup on stop
    unfreezeElementPosition()

    print("\n" .. string.rep("=", 70))
    print("ğŸ›‘ AUTO FARM (ELEMENT TAB) STOPPED")
    print(string.rep("=", 70))
    if cycleCount > 0 then
        local finalRate = (successCount / cycleCount) * 100
        print(string.format("\nğŸ“Š FINAL: %d cycles | %d success (%.1f%%) | %d teleports\n", cycleCount, successCount, finalRate, teleportCount))
    end

    _G.ELEMENT_FARM_LOOP_RUNNING = false
end

local function startElementFarm()
    if _G.AUTO_ELEMENT_FARM_ENABLED then
        print("âš ï¸ Element Farm already enabled!")
        return
    end

    print("\nğŸ£ Starting Auto Farm (Element Tab)...")
    _G.AUTO_ELEMENT_FARM_ENABLED = true

    startReelIntermissionLoop()

    if not _G.ELEMENT_FARM_LOOP_RUNNING then
        task.spawn(runElementFarmLoop)
    end

    print("âœ… Element Farm ENABLED\n")
end

local function stopElementFarm()
    if not _G.AUTO_ELEMENT_FARM_ENABLED then
        print("âš ï¸ Element Farm already stopped!")
        return
    end

    print("\nğŸ›‘ Stopping Auto Farm (Element Tab)...")
    _G.AUTO_ELEMENT_FARM_ENABLED = false

    stopReelIntermissionLoop()

    print("âœ… Element Farm stopped successfully\n")
end

print("âœ… Element farm module ready\n")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO WEATHER: Weather Purchase Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_G.WEATHER_LOOP_RUNNING = false

-- Weather types to purchase
local WEATHER_TYPES = {"Wind", "Cloudy", "Storm"}

-- Purchase single weather
local function purchaseWeather(weatherType)
    local success, result = pcall(function()
        local Event = game:GetService("ReplicatedStorage").Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseWeatherEvent"]
        return Event:InvokeServer(weatherType)
    end)

    if success then
        print(string.format("[Auto Weather] âœ… Purchased: %s", weatherType))
        return true
    else
        warn(string.format("[Auto Weather] âŒ Failed to purchase: %s", weatherType))
        return false
    end
end

-- Purchase all weather types (Wind, Cloudy, Storm)
local function purchaseAllWeathers()
    print(string.rep("-", 70))
    print("[Auto Weather] ğŸŒ¤ï¸ Purchasing all weather types...")

    local successCount = 0
    local failCount = 0

    for i, weatherType in ipairs(WEATHER_TYPES) do
        local success = purchaseWeather(weatherType)

        if success then
            successCount = successCount + 1
        else
            failCount = failCount + 1
        end

        -- 10ms delay between each purchase
        if i < #WEATHER_TYPES then
            task.wait(0.01)
        end
    end

    print(string.format("[Auto Weather] ğŸ“Š Batch complete: %d success, %d failed", successCount, failCount))
    print(string.rep("-", 70))

    return successCount, failCount
end

-- Auto weather loop
local function runAutoWeatherLoop()
    if _G.WEATHER_LOOP_RUNNING then
        print("âš ï¸ Auto Weather loop already running!")
        return
    end

    _G.WEATHER_LOOP_RUNNING = true

    print(string.rep("=", 70))
    print("ğŸŒ¤ï¸ AUTO WEATHER - STARTING")
    print(string.rep("=", 70) .. "\n")

    local cycleCount = 0
    local totalSuccess = 0
    local totalFailed = 0

    while _G.WEATHER_LOOP_RUNNING do
        -- Wait for auto weather to be enabled
        while not _G.AUTO_WEATHER_ENABLED and _G.WEATHER_LOOP_RUNNING do
            task.wait(0.5)
        end

        if not _G.WEATHER_LOOP_RUNNING then break end
        if not _G.AUTO_WEATHER_ENABLED then continue end

        cycleCount = cycleCount + 1

        print(string.format("\n[Auto Weather #%d] ğŸŒ¤ï¸ Starting weather purchase cycle...", cycleCount))

        -- Purchase all weathers
        local success, failed = purchaseAllWeathers()
        totalSuccess = totalSuccess + success
        totalFailed = totalFailed + failed

        -- Stats every 5 cycles
        if cycleCount % 5 == 0 then
            print(string.rep("=", 70))
            print(string.format("ğŸ“Š [AUTO WEATHER STATS]"))
            print(string.format("   Cycles: %d", cycleCount))
            print(string.format("   Total Purchases: %d", totalSuccess))
            print(string.format("   Total Failed: %d", totalFailed))
            print(string.format("   Delay: %ds", _G.WEATHER_PURCHASE_DELAY))
            print(string.format("   Status: %s", _G.AUTO_WEATHER_ENABLED and "ğŸŸ¢ ON" or "ğŸ”´ OFF"))
            print(string.rep("=", 70) .. "\n")
        end

        -- Wait before next cycle
        print(string.format("[Auto Weather #%d] â³ Waiting %ds before next purchase...\n", cycleCount, _G.WEATHER_PURCHASE_DELAY))
        task.wait(_G.WEATHER_PURCHASE_DELAY)
    end

    -- Cleanup
    print("\n" .. string.rep("=", 70))
    print("ğŸ›‘ AUTO WEATHER STOPPED")
    print(string.rep("=", 70))
    if cycleCount > 0 then
        print(string.format("\nğŸ“Š FINAL: %d cycles | %d purchases | %d failed\n", cycleCount, totalSuccess, totalFailed))
    end

    _G.WEATHER_LOOP_RUNNING = false
end

-- Start auto weather
local function startAutoWeather()
    if _G.AUTO_WEATHER_ENABLED then
        print("âš ï¸ Auto Weather already enabled!")
        return
    end

    print("\nğŸŒ¤ï¸ Starting Auto Weather...")
    _G.AUTO_WEATHER_ENABLED = true

    if not _G.WEATHER_LOOP_RUNNING then
        task.spawn(runAutoWeatherLoop)
    end

    print("âœ… Auto Weather ENABLED\n")
end

-- Stop auto weather
local function stopAutoWeather()
    if not _G.AUTO_WEATHER_ENABLED then
        print("âš ï¸ Auto Weather already stopped!")
        return
    end

    print("\nğŸ›‘ Stopping Auto Weather...")
    _G.AUTO_WEATHER_ENABLED = false

    print("âœ… Auto Weather stopped successfully\n")
end

print("âœ… Auto weather module ready\n")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- TELEPORT: Location Database & Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- Teleport locations (dapat ditambahkan lebih banyak di sini)
local teleportLocations = {
    { Name = "Kohana Volcano", CFrame = CFrame.new(-572.879456, 22.4521465, 148.355331, -0.995764792, -6.67705606e-08, 0.0919371247, -5.74611505e-08, 1, 1.03905414e-07, -0.0919371247, 9.81825394e-08, -0.995764792) },
    { Name = "Sisyphus Statue",  CFrame = CFrame.new(-3728.21606, -135.074417, -1012.12744, -0.977224171, 7.74980258e-09, -0.212209702, 1.566994e-08, 1, -3.5640408e-08, 0.212209702, -3.81539813e-08, -0.977224171) },
    { Name = "Coral Reefs",  CFrame = CFrame.new(-3114.78198, 1.32066584, 2237.52295, -0.304758579, 1.6556676e-08, -0.952429652, -8.50574935e-08, 1, 4.46003305e-08, 0.952429652, 9.46036067e-08, -0.304758579) },
    { Name = "Esoteric Depths",  CFrame = CFrame.new(3248.37109, -1301.53027, 1403.82727, -0.920208454, 7.76270355e-08, 0.391428679, 4.56261056e-08, 1, -9.10549289e-08, -0.391428679, -6.5930152e-08, -0.920208454) },
    { Name = "Crater Island",  CFrame = CFrame.new(1016.49072, 20.0919304, 5069.27295, 0.838976264, 3.30379857e-09, -0.544168055, 2.63538391e-09, 1, 1.01344115e-08, 0.544168055, -9.93662219e-09, 0.838976264) },
    { Name = "Spawn",  CFrame = CFrame.new(45.2788086, 252.562927, 2987.10913, 1, 0, 0, 0, 1, 0, 0, 0, 1) },
    { Name = "Lost Isle",  CFrame = CFrame.new(-3618.15698, 240.836655, -1317.45801, 1, 0, 0, 0, 1, 0, 0, 0, 1) },
    { Name = "Weather Machine",  CFrame = CFrame.new(-1488.51196, 83.1732635, 1876.30298, 1, 0, 0, 0, 1, 0, 0, 0, 1) },
    { Name = "Tropical Grove",  CFrame = CFrame.new(-2095.34106, 197.199997, 3718.08008) },
    { Name = "Mount Hallow",  CFrame = CFrame.new(2136.62305, 78.9163895, 3272.50439, -0.977613986, -1.77645827e-08, 0.210406482, -2.42338203e-08, 1, -2.81680421e-08, -0.210406482, -3.26364251e-08, -0.977613986) },
    { Name = "Treasure Room",  CFrame = CFrame.new(-3606.34985, -266.57373, -1580.97339, 0.998743415, 1.12141152e-13, -0.0501160324, -1.56847693e-13, 1, -8.88127842e-13, 0.0501160324, 8.94872392e-13, 0.998743415) },
    { Name = "Kohana",  CFrame = CFrame.new(-663.904236, 3.04580712, 718.796875, -0.100799225, -2.14183729e-08, -0.994906783, -1.12300391e-08, 1, -2.03902459e-08, 0.994906783, 9.11752096e-09, -0.100799225) },
    { Name = "Underground Cellar", CFrame = CFrame.new(2109.52148, -94.1875076, -708.609131, 0.418592364, 3.34794485e-08, -0.908174217, -5.24141512e-08, 1, 1.27060247e-08, 0.908174217, 4.22825366e-08, 0.418592364) },
    { Name = "Ancient Jungle", CFrame = CFrame.new(1831.71362, 6.62499952, -299.279175, 0.213522509, 1.25553285e-07, -0.976938128, -4.32026184e-08, 1, 1.19074642e-07, 0.976938128, 1.67811702e-08, 0.213522509) },
    { Name = "Sacred Temple", CFrame = CFrame.new(1466.92151, -21.8750591, -622.835693, -0.764787138, 8.14444334e-09, 0.644283056, 2.31097452e-08, 1, 1.4791004e-08, -0.644283056, 2.6201187e-08, -0.764787138) }
}

-- Teleport to location
local function teleportToLocation(locationName)
    local cframeData = TELEPORT_LOCATIONS[locationName]

    if not cframeData then
        warn(string.format("[Teleport] âŒ Location '%s' not found!", locationName))
        return false
    end

    local success = pcall(function()
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = cframeData
            print(string.format("[Teleport] âœ… Teleported to: %s", locationName))
        else
            warn("[Teleport] âŒ HumanoidRootPart not found!")
        end
    end)

    if not success then
        warn(string.format("[Teleport] âŒ Failed to teleport to: %s", locationName))
        return false
    end

    return true
end

print("âœ… Teleport module ready\n")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ELEMENT: Teleport Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- Teleport 3x to ensure accurate positioning
local function tripleTeleport(cframeData, locationName)
    local teleportSuccess = 0
    local teleportFailed = 0

    print(string.format("[Auto Element] ğŸ”„ Starting triple teleport to %s...", locationName))

    for i = 1, 3 do
        local success = pcall(function()
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = cframeData
            end
        end)

        if success then
            teleportSuccess = teleportSuccess + 1
            print(string.format("[Auto Element] âœ… Teleport #%d/%d successful", i, 3))
        else
            teleportFailed = teleportFailed + 1
            warn(string.format("[Auto Element] âŒ Teleport #%d/%d failed", i, 3))
        end

        -- Wait between teleports (except after the last one)
        if i < 3 then
            task.wait(0.3) -- 300ms delay between each teleport
        end
    end

    -- Final result
    if teleportSuccess == 3 then
        print(string.format("[Auto Element] âœ… Triple teleport completed successfully! (3/3)"))
        return true
    elseif teleportSuccess > 0 then
        warn(string.format("[Auto Element] âš ï¸ Partial teleport success (%d/3)", teleportSuccess))
        return true
    else
        warn(string.format("[Auto Element] âŒ All teleports failed (0/3)"))
        return false
    end
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO ELEMENT: Main Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function runAutoElementLoop()
    if isAutoElementRunning then
        print("âš ï¸ Auto Element loop already running!")
        return
    end

    isAutoElementRunning = true
    print(string.rep("=", 70))
    print("ğŸ”® AUTO ELEMENT LOOP - STARTING")
    print(string.rep("=", 70) .. "\n")

    local cycleCount = 0
    local teleportCount = 0
    local currentQuestLocation = nil  -- Track current quest location
    local hasTeleported = false       -- Track if we've already teleported for current quest
    local currentLabelSource = nil    -- Track which label (Label2 or Label3)

    while isAutoElementRunning and _G.AUTO_ELEMENT_ENABLED do
        cycleCount = cycleCount + 1

        print(string.format("\n[Auto Element #%d] ğŸ”® Checking quest status...", cycleCount))

        -- Get target location from tracker
        local targetLocation, labelSource = getTargetLocation()

        if targetLocation then
            -- Check if this is a NEW quest (different from current one)
            local isNewQuest = (targetLocation ~= currentQuestLocation) or (labelSource ~= currentLabelSource)

            if isNewQuest then
                -- Reset teleport flag for new quest
                hasTeleported = false
                currentQuestLocation = targetLocation
                currentLabelSource = labelSource
                print(string.format("[Auto Element] ğŸ†• NEW QUEST DETECTED: %s (from %s)", targetLocation, labelSource))
            end

            -- Only teleport if we haven't teleported for this quest yet
            if not hasTeleported then
                local cframeData = ELEMENT_LOCATIONS[targetLocation]

                if cframeData then
                    print(string.rep("=", 70))
                    print(string.format("[Auto Element] ğŸ“ TARGET: %s (from %s)", targetLocation, labelSource))
                    print(string.format("[Auto Element] ğŸš€ Preparing triple teleport in 3 seconds...", targetLocation))
                    task.wait(3) -- 3 second cooldown before teleport

                    -- Execute triple teleport for accuracy
                    local success = tripleTeleport(cframeData, targetLocation)

                    if success then
                        teleportCount = teleportCount + 1
                        hasTeleported = true  -- Mark as teleported
                        print(string.format("[Auto Element] âœ… Teleport complete! Now tracking quest progress..."))
                        print(string.format("[Auto Element] ğŸ“Š Total teleport cycles: %d", teleportCount))
                        print(string.rep("=", 70) .. "\n")
                    else
                        warn(string.format("[Auto Element] âŒ Triple teleport failed, will retry next cycle"))
                    end
                else
                    warn(string.rep("=", 70))
                    warn(string.format("[Auto Element] âš ï¸ Location '%s' not found in config!", targetLocation))

                    -- List available locations
                    local availableLocations = {}
                    for locName, _ in pairs(ELEMENT_LOCATIONS) do
                        table.insert(availableLocations, locName)
                    end
                    warn(string.format("[Auto Element] Available locations: %s", table.concat(availableLocations, ", ")))
                    warn(string.rep("=", 70))
                end
            else
                -- Already teleported, just track progress
                print(string.format("[Auto Element] ğŸ“ Current quest: %s (from %s)", targetLocation, labelSource))
                print(string.format("[Auto Element] â³ Waiting for quest completion (0%% â†’ 100%%)..."))
            end
        else
            -- No quest at 0% found
            if hasTeleported and currentQuestLocation then
                -- Previous quest completed!
                print(string.rep("=", 70))
                print(string.format("[Auto Element] âœ… QUEST COMPLETED: %s", currentQuestLocation))
                print(string.format("[Auto Element] ğŸ‰ Quest finished! Ready for next quest..."))
                print(string.rep("=", 70) .. "\n")
            else
                print("[Auto Element] â„¹ï¸ No incomplete quests found (Label2 & Label3 not at 0%)")
            end

            -- Reset tracking
            currentQuestLocation = nil
            currentLabelSource = nil
            hasTeleported = false
        end

        -- Wait 30 seconds before next check
        print(string.format("[Auto Element] â³ Next check in 30 seconds...\n"))
        task.wait(30)

        -- Stats every 5 cycles
        if cycleCount % 5 == 0 then
            print(string.rep("=", 70))
            print(string.format("ğŸ“Š [AUTO ELEMENT STATS]"))
            print(string.format("   Cycles: %d", cycleCount))
            print(string.format("   Total Teleports: %d", teleportCount))
            print(string.format("   Current Quest: %s", currentQuestLocation or "None"))
            print(string.format("   Quest Source: %s", currentLabelSource or "None"))
            print(string.format("   Teleported: %s", hasTeleported and "Yes" or "No"))
            print(string.format("   Status: %s", _G.AUTO_ELEMENT_ENABLED and "ğŸŸ¢ ON" or "ğŸ”´ OFF"))
            print(string.rep("=", 70) .. "\n")
        end
    end

    -- Cleanup
    print("\n" .. string.rep("=", 70))
    print("ğŸ›‘ AUTO ELEMENT LOOP STOPPED")
    print(string.rep("=", 70))
    if cycleCount > 0 then
        print(string.format("\nğŸ“Š FINAL STATS: %d cycles | %d teleports\n", cycleCount, teleportCount))
    end

    isAutoElementRunning = false
end

local function startAutoElement()
    if _G.AUTO_ELEMENT_ENABLED then
        print("âš ï¸ Auto Element already enabled!")
        return
    end

    print("\nğŸ”® Starting Auto Element...")
    _G.AUTO_ELEMENT_ENABLED = true

    -- Start the auto element loop
    if not isAutoElementRunning then
        task.spawn(runAutoElementLoop)
    end

    print("âœ… Auto Element ENABLED\n")
end

local function stopAutoElement()
    if not _G.AUTO_ELEMENT_ENABLED then
        print("âš ï¸ Auto Element already stopped!")
        return
    end

    print("\nğŸ›‘ Stopping Auto Element...")
    _G.AUTO_ELEMENT_ENABLED = false

    print("âœ… Auto Element stopped successfully\n")
end

print("âœ… Auto element module ready\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 3: INVENTORY MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    Inventory Module - Fish & Items detection system

    EDIT START: Line below this marker
    EDIT END: Before next section marker

    Key Functions:
    - detectFish() - Detect fish from inventory
    - detectItems() - Detect items from inventory
    - formatPrice() - Format price with commas
]]

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- INVENTORY: Helper Functions
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function trim(s)
    if not s then return nil end
    return s:match("^%s*(.-)%s*$")
end

local function formatPrice(price)
    if not price or price == 0 then return "0" end
    local formatted = tostring(math.floor(price))
    formatted = formatted:reverse():gsub("(%d%d%d)", "%1,")
    formatted = formatted:reverse():gsub("^,", "")
    return formatted
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- INVENTORY: Detection System
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local detectedFish = {}
local detectedItems = {}
local currentCategory = "Fishes" -- "Fishes" or "Items"
local isDetecting = false

-- Grouping System State
local isGroupingEnabled = false  -- Start with list view (backward compatibility)
local expandedGroups = {}        -- Track which groups are expanded: {[baseName] = true/false}
local currentDisplayedCategory = nil  -- Track currently displayed category: "Fishes" or "Items"

local function detectInventory(category)
    local detected = {}
    isDetecting = true

    print(string.format("[Inventory] Starting %s detection...", category))

    if not PlayerData then
        warn("[Inventory] PlayerData not available")
        isDetecting = false
        return detected
    end

    local success, inventory = pcall(function()
        return PlayerData:Get("Inventory")
    end)

    if not success or not inventory then
        warn("[Inventory] Failed to get inventory")
        isDetecting = false
        return detected
    end

    local itemsCategory = inventory["Items"]
    if not itemsCategory or type(itemsCategory) ~= "table" then
        warn("[Inventory] Items category not found")
        isDetecting = false
        return detected
    end

    print(string.format("[Inventory] Found %d total items", #itemsCategory))

    local itemCount = 0
    for i, item in ipairs(itemsCategory) do
        local itemData = ItemUtility:GetItemData(item.Id)
        if itemData and itemData.Data then
            local itemType = itemData.Data.Type
            local itemName = trim(itemData.Data.Name)
            local itemUUID = item.UUID

            local shouldInclude = false
            if category == "Fishes" and itemType == "Fish" then
                shouldInclude = true
            elseif category == "Items" and itemType ~= "Fish" then
                shouldInclude = true
            end

            if shouldInclude then
                local mutation = nil
                local originalName = itemName

                -- Detect Big mutation
                if string.find(itemName, "^Big ") then
                    mutation = "Big"
                    itemName = trim(string.gsub(itemName, "^Big ", ""))
                -- Detect Shiny mutation
                elseif string.find(itemName, "^Shiny ") then
                    mutation = "Shiny"
                    itemName = trim(string.gsub(itemName, "^Shiny ", ""))
                end

                -- Detect variant mutations
                if not mutation and item.Metadata and item.Metadata.VariantId then
                    local variantData = ItemUtility:GetVariantData(item.Metadata.VariantId)
                    if variantData and variantData.Data.Name and variantData.Data.Name ~= "Ghoulish" then
                        mutation = variantData.Data.Name
                    end
                end

                local itemPrice = VendorUtility:GetSellPrice(item) or 0
                local basePrice = itemData.SellPrice or 0

                table.insert(detected, {
                    index = itemCount + 1,
                    name = itemName,
                    originalName = originalName,
                    mutation = mutation,
                    uuid = itemUUID,
                    category = category,
                    itemType = itemType,
                    price = itemPrice,
                    basePrice = basePrice
                })
                itemCount = itemCount + 1
            end
        end
    end

    print(string.format("[Inventory] Detected %d %s", itemCount, category))
    isDetecting = false
    return detected
end

local function detectFish()
    detectedFish = detectInventory("Fishes")
    return detectedFish
end

local function detectItems()
    detectedItems = detectInventory("Items")
    return detectedItems
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- INVENTORY: Grouping System
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function groupInventoryItems(items)
    local groups = {}
    local groupOrder = {}

    for i, item in ipairs(items) do
        local baseName = item.name  -- Base name for grouping

        -- Create new group if doesn't exist
        if not groups[baseName] then
            groups[baseName] = {
                baseName = baseName,
                items = {},
                totalCount = 0,
                totalValue = 0,
                avgPrice = 0,
                maxPrice = 0,
                minPrice = 999999999,
                isExpanded = expandedGroups[baseName] or false
            }
            table.insert(groupOrder, baseName)
        end

        -- Preserve original index
        local itemWithIndex = {}
        for k, v in pairs(item) do
            itemWithIndex[k] = v
        end
        itemWithIndex.originalIndex = i

        -- Add item to group
        table.insert(groups[baseName].items, itemWithIndex)
        groups[baseName].totalCount = groups[baseName].totalCount + 1

        -- Update statistics
        local itemPrice = item.price or 0
        groups[baseName].totalValue = groups[baseName].totalValue + itemPrice

        if itemPrice > groups[baseName].maxPrice then
            groups[baseName].maxPrice = itemPrice
        end

        if itemPrice < groups[baseName].minPrice then
            groups[baseName].minPrice = itemPrice
        end
    end

    -- Calculate averages
    for _, group in pairs(groups) do
        if group.totalCount > 0 then
            group.avgPrice = math.floor(group.totalValue / group.totalCount)
        end
    end

    return groups, groupOrder
end

print("âœ… Inventory module ready\n")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 4: UI MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    UI Module - WindUI interface

    EDIT START: Line below this marker
    EDIT END: Before next section marker

    Tabs:
    - Auto Farm: Toggle ON/OFF, Custom Delay
    - Inventory: Fish/Items detection
]]

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI: Load WindUI
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

print("ğŸ“¦ Loading WindUI...")
local WindUI
local uiSuccess, uiError = pcall(function()
    WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)

if not uiSuccess then
    warn("âŒ Failed to load WindUI: " .. tostring(uiError))
    warn("âš ï¸ Running without UI - Auto Farm enabled by default")
    _G.AUTO_FARM_ENABLED = true
    task.spawn(runMainLoop)
    return
end

print("âœ… WindUI loaded successfully\n")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI: Create Window
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local Window = WindUI:CreateWindow({
    Title = "Auto Fishing Hub v2",
    Author = "by Daryl",
    Folder = "AutoFishingHub",
    Icon = "fish",
    Size = UDim2.fromOffset(520, 500),
    Resizable = false,
    Theme = "Dark"
})

print("âœ… Window created")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI: AUTO FARM TAB
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local FarmTab = Window:Tab({
    Title = "Auto Farm",
    Icon = "zap"
})

FarmTab:Section({
    Title = "âš™ï¸ Farm Controls"
})

-- Stop function
local function stopAutoFarm()
    print("\nğŸ›‘ Stopping Auto Farm...")
    _G.AUTO_FARM_ENABLED = false

    task.spawn(function()
        pcall(function()
            CancelEvent:InvokeServer()
            print("âœ… Sent CancelFishingInputs (1x)")
        end)
    end)

    print("âœ… Auto Farm stopped successfully\n")
end

-- Start function
local function startAutoFarm()
    print("\nğŸš€ Starting Auto Farm...")
    _G.AUTO_FARM_ENABLED = true

    startReelIntermissionLoop()

    if not _G.MAIN_LOOP_RUNNING then
        task.spawn(runMainLoop)
    end

    print("âœ… Auto Farm ENABLED\n")
end

-- Toggle
FarmTab:Toggle({
    Title = "Auto Farm",
    Desc = "Enable/disable automatic fishing",
    Type = "Toggle",
    Default = false,
    Flag = "AutoFarmEnabled",
    Callback = function(state)
        if state then
            startAutoFarm()
        else
            stopAutoFarm()
        end
    end
})

FarmTab:Space({ Size = 10 })

-- Delay Input
FarmTab:Input({
    Title = "Success Delay",
    Desc = "Delay after successful fishing (seconds)",
    Type = "Input",
    Placeholder = "1",
    Value = "1",
    InputIcon = "timer",
    Callback = function(value)
        local delay = tonumber(value)
        if delay and delay > 0 then
            _G.FARM_SUCCESS_DELAY = delay
            print(string.format("â±ï¸ Success delay: %.2fs", delay))
        else
            print("âŒ Invalid delay! Using default: 1s")
            _G.FARM_SUCCESS_DELAY = 1
        end
    end
})

FarmTab:Space({ Size = 20 })

FarmTab:Divider()

FarmTab:Space({ Size = 15 })

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO FARM TAB: Auto Sell Section
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FarmTab:Section({
    Title = "ğŸ’° Auto Sell"
})

-- Auto Sell Toggle
FarmTab:Toggle({
    Title = "Auto Sell",
    Desc = "Automatically sell all items periodically",
    Type = "Toggle",
    Default = false,
    Flag = "AutoSellEnabled",
    Callback = function(state)
        if state then
            startAutoSell()
        else
            stopAutoSell()
        end
    end
})

FarmTab:Space({ Size = 10 })

-- Auto Sell Delay Input
FarmTab:Input({
    Title = "Sell Delay",
    Desc = "Delay between auto-sell cycles (seconds)",
    Type = "Input",
    Placeholder = "60",
    Value = "60",
    InputIcon = "timer",
    Callback = function(value)
        local delay = tonumber(value)
        if delay and delay >= 10 then
            _G.AUTO_SELL_DELAY = delay
            print(string.format("ğŸ’° Auto Sell delay set to: %ds", delay))
        else
            print("âŒ Invalid delay! Minimum 10 seconds. Using default: 60s")
            _G.AUTO_SELL_DELAY = 60
        end
    end
})

FarmTab:Space({ Size = 20 })

FarmTab:Divider()

FarmTab:Space({ Size = 15 })

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO FARM TAB: Auto Artifact Section
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FarmTab:Section({
    Title = "ğŸ¯ Auto Artifact"
})

-- Auto Artifact Toggle
FarmTab:Toggle({
    Title = "Auto Artifact",
    Desc = "Enable/disable automatic artifact collection",
    Type = "Toggle",
    Default = false,
    Flag = "AutoArtifactEnabled",
    Callback = function(state)
        if state then
            startAutoArtifact()
        else
            stopAutoArtifact()
        end
    end
})

FarmTab:Space({ Size = 10 })

-- Artifact Skip Toggles Section
FarmTab:Section({
    Title = "ğŸ¯ Artifact Skip Settings"
})

FarmTab:Paragraph({
    Title = "Skip Artifacts",
    Desc = "Toggle ON to skip artifacts you already have"
})

FarmTab:Space({ Size = 5 })

-- Temple 1: Hourglass Diamond Artifact
FarmTab:Toggle({
    Title = "â­ï¸ Skip Hourglass Diamond",
    Desc = "Temple 1 - Mark as already obtained",
    Type = "Toggle",
    Default = false,
    Flag = "SkipHourglassDiamond",
    Callback = function(state)
        artifactSkipToggles[1] = state
        local status = state and "WILL SKIP" or "WILL FARM"
        print(string.format("[Skip Settings] Hourglass Diamond: %s", status))
    end
})

-- Temple 2: Arrow Artifact
FarmTab:Toggle({
    Title = "â­ï¸ Skip Arrow Artifact",
    Desc = "Temple 2 - Mark as already obtained",
    Type = "Toggle",
    Default = false,
    Flag = "SkipArrowArtifact",
    Callback = function(state)
        artifactSkipToggles[2] = state
        local status = state and "WILL SKIP" or "WILL FARM"
        print(string.format("[Skip Settings] Arrow Artifact: %s", status))
    end
})

-- Temple 3: Diamond Artifact
FarmTab:Toggle({
    Title = "â­ï¸ Skip Diamond Artifact",
    Desc = "Temple 3 - Mark as already obtained",
    Type = "Toggle",
    Default = false,
    Flag = "SkipDiamondArtifact",
    Callback = function(state)
        artifactSkipToggles[3] = state
        local status = state and "WILL SKIP" or "WILL FARM"
        print(string.format("[Skip Settings] Diamond Artifact: %s", status))
    end
})

-- Temple 4: Crescent Artifact
FarmTab:Toggle({
    Title = "â­ï¸ Skip Crescent Artifact",
    Desc = "Temple 4 - Mark as already obtained",
    Type = "Toggle",
    Default = false,
    Flag = "SkipCrescentArtifact",
    Callback = function(state)
        artifactSkipToggles[4] = state
        local status = state and "WILL SKIP" or "WILL FARM"
        print(string.format("[Skip Settings] Crescent Artifact: %s", status))
    end
})

FarmTab:Space({ Size = 10 })

FarmTab:Divider()

FarmTab:Space({ Size = 15 })

-- Manual Teleport Section
FarmTab:Section({
    Title = "ğŸ—ºï¸ Manual Temple Teleport"
})

FarmTab:Paragraph({
    Title = "Quick Teleport",
    Desc = "Teleport to temples manually without auto-farm"
})

FarmTab:Space({ Size = 5 })

-- Temple 1: Hourglass Diamond Artifact
FarmTab:Button({
    Title = "ğŸ“ Temple 1 - Hourglass Diamond",
    Desc = "Teleport to Temple 1 location",
    Callback = function()
        local success = pcall(function()
            local rootPart = player.Character.HumanoidRootPart
            rootPart.CFrame = CFrame.new(1490.12305, 6.62499952, -850.539307, -0.982308805, -4.67861128e-09, -0.187268242, -7.57854224e-09, 1, 1.47694985e-08, 0.187268242, 1.59274283e-08, -0.982308805)
            print("[Teleport] âœ… Teleported to Temple 1 (Hourglass Diamond)")
        end)
        if not success then
            warn("[Teleport] âŒ Failed to teleport to Temple 1")
        end
    end
})

-- Temple 2: Arrow Artifact
FarmTab:Button({
    Title = "ğŸ“ Temple 2 - Arrow Artifact",
    Desc = "Teleport to Temple 2 location",
    Callback = function()
        local success = pcall(function()
            local rootPart = player.Character.HumanoidRootPart
            rootPart.CFrame = CFrame.new(883.964233, 6.62499952, -360.91275, -0.128746182, 9.21072107e-09, 0.991677582, -4.92979968e-09, 1, -9.92803972e-09, -0.991677582, -6.16696871e-09, -0.128746182)
            print("[Teleport] âœ… Teleported to Temple 2 (Arrow Artifact)")
        end)
        if not success then
            warn("[Teleport] âŒ Failed to teleport to Temple 2")
        end
    end
})

-- Temple 3: Diamond Artifact
FarmTab:Button({
    Title = "ğŸ“ Temple 3 - Diamond Artifact",
    Desc = "Teleport to Temple 3 location",
    Callback = function()
        local success = pcall(function()
            local rootPart = player.Character.HumanoidRootPart
            rootPart.CFrame = CFrame.new(1836.77136, 6.62499952, -288.573303, 0.25269559, 7.76984699e-09, -0.967545807, 3.12285877e-08, 1, 1.61864921e-08, 0.967545807, -3.43053443e-08, 0.25269559)
            print("[Teleport] âœ… Teleported to Temple 3 (Diamond Artifact)")
        end)
        if not success then
            warn("[Teleport] âŒ Failed to teleport to Temple 3")
        end
    end
})

-- Temple 4: Crescent Artifact
FarmTab:Button({
    Title = "ğŸ“ Temple 4 - Crescent Artifact",
    Desc = "Teleport to Temple 4 location",
    Callback = function()
        local success = pcall(function()
            local rootPart = player.Character.HumanoidRootPart
            rootPart.CFrame = CFrame.new(1405.67358, 6.17587185, 119.126236, -0.951030135, -6.02376886e-08, 0.309098154, -8.03642095e-08, 1, -5.23817469e-08, -0.309098154, -7.4657045e-08, -0.951030135)
            print("[Teleport] âœ… Teleported to Temple 4 (Crescent Artifact)")
        end)
        if not success then
            warn("[Teleport] âŒ Failed to teleport to Temple 4")
        end
    end
})

print("âœ… Auto Farm tab created")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI: INVENTORY TAB
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local InventoryTab = Window:Tab({
    Title = "Inventory",
    Icon = "package"
})

InventoryTab:Section({
    Title = "ğŸ“¦ Inventory Detection"
})

-- Detection status label
local detectionStatus = nil
local fishListLabels = {}
local itemListLabels = {}
local allInventoryUIComponents = {}  -- Track ALL created UI components

-- Helper function to clear list (IMPROVED)
local function clearList(listTable)
    for _, label in ipairs(listTable) do
        if label then
            pcall(function() label:Destroy() end)
        end
    end
    table.clear(listTable)
end

-- Clear ALL inventory UI components
local function clearAllInventoryUI()
    for _, component in ipairs(allInventoryUIComponents) do
        if component then
            pcall(function() component:Destroy() end)
        end
    end
    table.clear(allInventoryUIComponents)
    table.clear(fishListLabels)
    table.clear(itemListLabels)
end

-- Refresh Inventory Display (Main rendering function)
local function refreshInventoryDisplay(category)
    -- Clear previous UI
    clearAllInventoryUI()

    -- Get current items based on category
    local currentItems = (category == "Fishes") and detectedFish or detectedItems

    if #currentItems == 0 then
        local noItemsLabel = InventoryTab:Paragraph({
            Title = string.format("No %s detected yet", category:lower()),
            Desc = string.format("Click 'Detect %s' button to scan", category)
        })
        table.insert(allInventoryUIComponents, noItemsLabel)
        return
    end

    -- Calculate statistics
    local totalValue = 0
    local mutatedCount = 0
    for _, item in ipairs(currentItems) do
        totalValue = totalValue + (item.price or 0)
        if category == "Fishes" and item.mutation and item.mutation ~= "" then
            mutatedCount = mutatedCount + 1
        end
    end

    -- Update detection status
    local statusText
    if category == "Fishes" then
        statusText = string.format(
            "ğŸŸ Fish: %d | ğŸ’ Mutated: %d\nğŸ’° Total Value: %s C$",
            #currentItems,
            mutatedCount,
            formatPrice(totalValue)
        )
    else
        statusText = string.format(
            "ğŸ“¦ Items: %d\nğŸ’° Total Value: %s C$",
            #currentItems,
            formatPrice(totalValue)
        )
    end

    if detectionStatus then
        detectionStatus:SetDesc(statusText)
    end

    -- GROUPED VIEW
    if isGroupingEnabled then
        local groups, groupOrder = groupInventoryItems(currentItems)

        print(string.format("[Inventory] Rendering GROUPED view: %d groups", #groupOrder))

        for _, groupName in ipairs(groupOrder) do
            local group = groups[groupName]

            -- Group Header Button
            local expandIcon = group.isExpanded and "ğŸ“‚" or "ğŸ“"
            local headerTitle = string.format(
                "%s %s | Count: %d | Total: %s C$ | Avg: %s C$",
                expandIcon,
                groupName,
                group.totalCount,
                formatPrice(group.totalValue),
                formatPrice(group.avgPrice)
            )

            local groupHeader = InventoryTab:Button({
                Title = headerTitle,
                Desc = "Click to expand/collapse",
                Callback = function()
                    -- Toggle expand state
                    expandedGroups[groupName] = not expandedGroups[groupName]
                    refreshInventoryDisplay(category)
                end
            })
            table.insert(allInventoryUIComponents, groupHeader)

            -- Child Items (if expanded)
            if group.isExpanded then
                -- Sort items by price (highest first)
                table.sort(group.items, function(a, b) return (a.price or 0) > (b.price or 0) end)

                for idx, item in ipairs(group.items) do
                    local itemTitle = string.format(
                        "  â†’ %s%s - %s C$",
                        item.originalName or item.name,
                        item.mutation and (" (" .. item.mutation .. ")") or "",
                        formatPrice(item.price)
                    )

                    local itemEntry = InventoryTab:Paragraph({
                        Title = itemTitle,
                        Desc = ""
                    })
                    table.insert(allInventoryUIComponents, itemEntry)

                    -- Limit display to prevent UI overflow
                    if idx >= 50 then
                        local moreLabel = InventoryTab:Paragraph({
                            Title = string.format("    ... and %d more items in this group", group.totalCount - 50),
                            Desc = ""
                        })
                        table.insert(allInventoryUIComponents, moreLabel)
                        break
                    end
                end
            end
        end

    -- LIST VIEW
    else
        print(string.format("[Inventory] Rendering LIST view: %d items", #currentItems))

        -- Sort by price (highest first)
        local sortedItems = {}
        for i, item in ipairs(currentItems) do
            local itemCopy = {}
            for k, v in pairs(item) do itemCopy[k] = v end
            itemCopy.originalIndex = i
            table.insert(sortedItems, itemCopy)
        end
        table.sort(sortedItems, function(a, b) return (a.price or 0) > (b.price or 0) end)

        -- Display items (limit to 50 to prevent UI overflow)
        local displayLimit = math.min(50, #sortedItems)
        for i = 1, displayLimit do
            local item = sortedItems[i]
            local itemTitle = string.format(
                "%d. %s%s - %s C$",
                i,
                item.originalName or item.name,
                item.mutation and (" (" .. item.mutation .. ")") or "",
                formatPrice(item.price)
            )

            local itemEntry = InventoryTab:Paragraph({
                Title = itemTitle,
                Desc = ""
            })
            table.insert(allInventoryUIComponents, itemEntry)
        end

        -- Show "more items" indicator
        if #sortedItems > 50 then
            local moreLabel = InventoryTab:Paragraph({
                Title = string.format("... and %d more items", #sortedItems - 50),
                Desc = ""
            })
            table.insert(allInventoryUIComponents, moreLabel)
        end
    end
end

-- Helper function to create fish/item entry (DEPRECATED - kept for backward compatibility)
local function createListEntry(tab, name, mutation, price, index)
    local displayText = string.format(
        "%d. %s%s - %s C$",
        index,
        name,
        mutation and (" (" .. mutation .. ")") or "",
        formatPrice(price)
    )

    return tab:Paragraph({
        Title = displayText,
        Desc = ""
    })
end

-- Grouping Toggle Button
InventoryTab:Button({
    Title = isGroupingEnabled and "ğŸ“‹ Switch to List View" or "ğŸ“¦ Switch to Group View",
    Desc = "Toggle between grouped and list display",
    Callback = function()
        isGroupingEnabled = not isGroupingEnabled
        print(string.format("[Inventory] Switched to %s view", isGroupingEnabled and "GROUPED" or "LIST"))

        -- Refresh display if items are already loaded
        if currentDisplayedCategory then
            refreshInventoryDisplay(currentDisplayedCategory)
        end
    end
})

InventoryTab:Space({ Size = 10 })

-- Detect Fish Button
InventoryTab:Button({
    Title = "ğŸŸ Detect Fish",
    Desc = "Scan inventory for all fish",
    Callback = function()
        print("\n[Inventory] Starting fish detection...")

        -- Set status to loading
        if detectionStatus then
            detectionStatus:SetDesc("â³ Detecting fish...")
        end

        -- Detect fish from inventory
        local fish = detectFish()
        print(string.format("[Inventory] âœ… Detected %d fish", #fish))

        -- Update current category and refresh display
        currentDisplayedCategory = "Fishes"
        refreshInventoryDisplay("Fishes")
    end
})

InventoryTab:Space({ Size = 5 })

-- Detect Items Button
InventoryTab:Button({
    Title = "ğŸ“¦ Detect Items",
    Desc = "Scan inventory for all items (non-fish)",
    Callback = function()
        print("\n[Inventory] Starting items detection...")

        -- Set status to loading
        if detectionStatus then
            detectionStatus:SetDesc("â³ Detecting items...")
        end

        -- Detect items from inventory
        local items = detectItems()
        print(string.format("[Inventory] âœ… Detected %d items", #items))

        -- Update current category and refresh display
        currentDisplayedCategory = "Items"
        refreshInventoryDisplay("Items")
    end
})

InventoryTab:Space({ Size = 15 })

InventoryTab:Divider()

InventoryTab:Space({ Size = 10 })

-- Status Display
InventoryTab:Section({
    Title = "ğŸ“Š Detection Status"
})

detectionStatus = InventoryTab:Paragraph({
    Title = "Status",
    Desc = "âšª No detection run yet\nClick 'Detect Fish' or 'Detect Items' to start"
})

print("âœ… Inventory tab created")

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI: AUTO ELEMENT TAB
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local ElementTab = Window:Tab({
    Title = "Auto Element",
    Icon = "star"
})

ElementTab:Section({
    Title = "ğŸ”® Element Controls"
})

-- Auto Element Toggle
ElementTab:Toggle({
    Title = "Auto Element",
    Desc = "Enable/disable automatic element collection",
    Type = "Toggle",
    Default = false,
    Flag = "AutoElementEnabled",
    Callback = function(state)
        if state then
            startAutoElement()
        else
            stopAutoElement()
        end
    end
})

ElementTab:Space({ Size = 20 })

ElementTab:Divider()

ElementTab:Space({ Size = 15 })

-- Auto Farm Section (Element Tab)
ElementTab:Section({
    Title = "ğŸ£ Auto Farm (Simplified)"
})

-- Auto Farm Toggle
ElementTab:Toggle({
    Title = "Auto Farm",
    Desc = "Simplified auto fishing (Equip â†’ Charge â†’ Request â†’ Wait â†’ Complete)",
    Type = "Toggle",
    Default = false,
    Flag = "AutoElementFarmEnabled",
    Callback = function(state)
        if state then
            startElementFarm()
        else
            stopElementFarm()
        end
    end
})

ElementTab:Space({ Size = 10 })

-- Custom Wait Input (Before Complete)
ElementTab:Input({
    Title = "Wait Before Complete",
    Desc = "Wait time before completing catch (seconds)",
    Type = "Input",
    Placeholder = "1",
    Value = "1",
    InputIcon = "timer",
    Callback = function(value)
        local wait = tonumber(value)
        if wait and wait > 0 then
            _G.ELEMENT_FARM_WAIT = wait
            print(string.format("â±ï¸ Element Farm wait before complete: %.2fs", wait))
        else
            print("âŒ Invalid wait time! Using default: 1s")
            _G.ELEMENT_FARM_WAIT = 1
        end
    end
})

ElementTab:Space({ Size = 10 })

-- Custom Wait Input (After Complete)
ElementTab:Input({
    Title = "Wait After Complete",
    Desc = "Wait time after completing catch before restarting loop (seconds)",
    Type = "Input",
    Placeholder = "1",
    Value = "1",
    InputIcon = "clock",
    Callback = function(value)
        local wait = tonumber(value)
        if wait and wait > 0 then
            _G.ELEMENT_FARM_AFTER_COMPLETE_WAIT = wait
            print(string.format("â±ï¸ Element Farm wait after complete: %.2fs", wait))
        else
            print("âŒ Invalid wait time! Using default: 1s")
            _G.ELEMENT_FARM_AFTER_COMPLETE_WAIT = 1
        end
    end
})

ElementTab:Space({ Size = 20 })

ElementTab:Divider()

ElementTab:Space({ Size = 15 })

ElementTab:Section({
    Title = "â„¹ï¸ Element Tracker Info"
})

-- Element Tracker Status Paragraph
local elementTrackerStatus = ElementTab:Paragraph({
    Title = "ğŸ“Š Quest Status",
    Desc = "â³ Loading tracker data..."
})

-- Auto-update Element Tracker every 31 seconds
task.spawn(function()
    while true do
        task.wait(31)

        local status = getElementTrackerStatus()

        if elementTrackerStatus then
            pcall(function()
                elementTrackerStatus:SetDesc(status)
            end)
        end

        print("[Element Tracker] Updated: " .. os.date("%H:%M:%S"))
    end
end)

-- Initial update (immediate)
task.spawn(function()
    task.wait(2) -- Wait for UI to fully load
    local status = getElementTrackerStatus()
    if elementTrackerStatus then
        pcall(function()
            elementTrackerStatus:SetDesc(status)
        end)
    end
    print("[Element Tracker] Initial update completed")
end)

print("âœ… Auto Element tab created")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 4.5: WEATHER TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local WeatherTab = Window:Tab({
    Title = "Weather",
    Icon = "cloud"
})

WeatherTab:Section({
    Title = "ğŸŒ¤ï¸ Weather Controls"
})

-- Auto Weather Toggle
WeatherTab:Toggle({
    Title = "Auto Weather",
    Desc = "Auto-purchase Wind, Cloudy, and Storm weather",
    Type = "Toggle",
    Default = false,
    Flag = "AutoWeatherEnabled",
    Callback = function(state)
        if state then
            startAutoWeather()
        else
            stopAutoWeather()
        end
    end
})

WeatherTab:Space({ Size = 10 })

-- Purchase Delay Input
WeatherTab:Input({
    Title = "Purchase Delay",
    Desc = "Delay between weather purchase cycles (seconds)",
    Type = "Input",
    Placeholder = "32",
    Value = "32",
    InputIcon = "clock",
    Callback = function(value)
        local delay = tonumber(value)
        if delay and delay > 0 then
            _G.WEATHER_PURCHASE_DELAY = delay
            print(string.format("â±ï¸ Weather purchase delay: %ds", delay))
        else
            print("âŒ Invalid delay! Using default: 32s")
            _G.WEATHER_PURCHASE_DELAY = 32
        end
    end
})

WeatherTab:Space({ Size = 20 })

WeatherTab:Divider()

WeatherTab:Space({ Size = 15 })

WeatherTab:Section({
    Title = "â„¹ï¸ Weather Info"
})

WeatherTab:Paragraph({
    Title = "ğŸ“‹ Purchase Order",
    Desc = "1. Wind\n2. Cloudy\n3. Storm\n\nDelay: 0.01s between each weather\nCycle delay: Custom (default 32s)"
})

WeatherTab:Space({ Size = 15 })

WeatherTab:Paragraph({
    Title = "âš™ï¸ How It Works",
    Desc = "When enabled, this will automatically purchase Wind, Cloudy, and Storm weather in sequence every X seconds (configurable delay).\n\nUse this to keep weather effects active continuously."
})

print("âœ… Auto Weather tab created")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 4.6: TELEPORT TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TeleportTab = Window:Tab({
    Title = "Teleport",
    Icon = "map-pin"
})

TeleportTab:Section({
    Title = "ğŸ“ Teleport Locations"
})

-- Sacred Temple Button
TeleportTab:Button({
    Title = "Sacred Temple",
    Desc = "Teleport to Sacred Temple",
    Callback = function()
        teleportToLocation("Sacred Temple")
    end
})

TeleportTab:Space({ Size = 10 })

-- Placeholder untuk lokasi tambahan (bisa ditambahkan nanti)
--[[
TeleportTab:Button({
    Title = "Ancient Jungle",
    Desc = "Teleport to Ancient Jungle",
    Callback = function()
        teleportToLocation("Ancient Jungle")
    end
})

TeleportTab:Space({ Size = 10 })
]]

TeleportTab:Divider()

TeleportTab:Space({ Size = 15 })

TeleportTab:Section({
    Title = "â„¹ï¸ Info"
})

TeleportTab:Paragraph({
    Title = "ğŸ“Œ Available Locations",
    Desc = "â€¢ Sacred Temple\n\nMore locations can be added to TELEPORT_LOCATIONS table in the code."
})

TeleportTab:Space({ Size = 15 })

TeleportTab:Paragraph({
    Title = "âš™ï¸ How to Add Locations",
    Desc = "1. Find the location's CFrame coordinates\n2. Add to TELEPORT_LOCATIONS table (line ~1770)\n3. Add button in this tab UI\n\nFormat:\n[\"Location Name\"] = CFrame.new(...)"
})

print("âœ… Teleport tab created")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECTION 5: MAIN EXECUTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--[[
    Main Execution - Auto-start and initialization

    DO NOT MODIFY unless changing startup behavior
]]

-- Start the main loop thread (waits for AUTO_FARM_ENABLED)
task.spawn(runMainLoop)

print(string.rep("=", 80))
print("âœ… ALL SYSTEMS LOADED!")
print(string.rep("=", 80))
print("\nğŸ® UI is ready!")
print("ğŸ“‹ Features:")
print("  âœ… Auto Farm Tab - Toggle & Custom Delay")
print("  âœ… Auto Element Tab - Element Collection System")
print("  âœ… Inventory Tab - Fish & Items Detection")
print(string.rep("=", 80) .. "\n")
